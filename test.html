<html lang="en">
	<head>
		<title>Test</title>
		<link href="styles/reset.css" rel="stylesheet" type="text/css">
		<script src="scripts/jquery.js" type="text/javascript"></script>
		<script src="scripts/underscore.js" type="text/javascript"></script>
		<script src="scripts/backbone.js" type="text/javascript"></script>
		<script src="scripts/ace/ace.js" type="text/javascript"></script>
		<meta charset="UTF-8">
		<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
	</head>
	<body>
		<div style="height: 200px; position: relative; width: 400px;" class="oj-AceEditor" id="ojXOplLgqv" padding="20"></div>
		<a class="twitter-follow-button oj-TwitterFollowButton" data-show-count="false" data-show-screen-name="true" href="https://twitter.com/evanmoran" style="display:none" id="ojLhrBzNR0">Follow @evanmoran</a>
		<a class="twitter-follow-button oj-TwitterFollowButton" data-show-count="false" data-show-screen-name="true" href="https://twitter.com/iamthelawton" style="display:none" id="ojdGcwcbC8">Follow @iamthelawton</a>
		<iframe allowFullScreen="1" frameborder="0" mozallowfullscreen="1" src="http://player.vimeo.com/video/24715531?api=1&amp;player_id=0&amp;title=0&amp;byline=0&amp;portrait=0&amp;color=00adef&amp;autoplay=0&amp;loop=0&amp;player_id=0" webkitAllowFullScreen="1" class="oj-VimeoVideo" width="400" height="224" id="ojP1Pso9y4"></iframe>
		<br>
	<script>

// Generated with oj v0.0.14
(function(){ var F = {}, M = {}, R = {}, P, G, RR;

M['/node_modules'] = {"underscore":"underscore.js","oj-ace-editor":"src/oj.AceEditor.js","oj-vimeo-video":"src/oj.VimeoVideo.js","oj-twitter-follow-button":"src/oj.TwitterFollowButton.js"};
F['/test.ojc'] = (function(module,exports){(function(require,process,global,__dirname,__filename){(function(){with(oj.sandbox){var _;

_ = require('underscore');

oj.use(require('oj-ace-editor'));

oj.use(require('oj-vimeo-video'));

oj.use(require('oj-twitter-follow-button'));

module.exports = html({
  lang: 'en'
}, function() {
  head(function() {
    title('Test');
    link({
      url: 'styles/reset.css'
    });
    script({
      url: 'scripts/jquery.js'
    });
    script({
      url: 'scripts/underscore.js'
    });
    script({
      url: 'scripts/backbone.js'
    });
    script({
      url: 'scripts/ace/ace.js'
    });
    meta({
      charset: 'UTF-8'
    });
    return meta({
      'http-equiv': "X-UA-Compatible",
      content: 'IE=edge,chrome=1'
    });
  });
  return body(function() {
    var CodeModel, ae, code;

    if (oj.isClient) {
      CodeModel = Backbone.Model.extend();
      code = new CodeModel({
        code: 'function test(){\n}\nvar foo = 5;'
      });
    }
    ae = AceEditor({
      model: code,
      key: 'code',
      wrapLimit: '23',
      mode: 'javascript',
      theme: 'solarized_light',
      padding: 20
    });
    TwitterFollowButton('evanmoran');
    TwitterFollowButton('iamthelawton');
    VimeoVideo();
    return br();
  });
});
}}).call(this);})(RR('/test.ojc'),P,G,'/','test.ojc');});
F['/node_modules/underscore/underscore.js'] = (function(module,exports){(function(require,process,global,__dirname,__filename){//     Underscore.js 1.4.4
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.4';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? null : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(context, args.concat(slice.call(arguments)));
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);
})(RR('/node_modules/underscore/underscore.js'),P,G,'/node_modules/underscore','underscore.js');});
F['/node_modules/oj-ace-editor/src/oj.AceEditor.js'] = (function(module,exports){(function(require,process,global,__dirname,__filename){// oj.AceEditor.js

var debounce;

module.exports = function(oj,settings){

  if (typeof settings !== 'object')
    settings = {}

  var AceEditor = oj.type('AceEditor', {
    base: oj.ModelKeyView,

    constructor: function(){
      var union = oj.argumentsUnion(arguments);
      var options = union.options;
      var args = union.args;

      // Normally oj.View automatically creates an oj.id for us, but the ace editor
      // is triggered by id so we need a reference to it at this level.
      options.id = options.id || oj.id()

      // Default options
      var defaults = {
        width: '400px',           // Default the height
        height: '200px',          // Default the width
        fontSize: 14,             // Default font size
        showFoldWidgets: false,   // Hide fold widgets
        showPrintMargin: false,   // Hide print margin
        useSoftTabs: true,        // Change tabs to spaces
        behaviorsEnabled: true,   // Enable quote and paren matching
        foldStyle: 'markbegin',   // Default fold style when folds are unhidden

        // Disable workers on local files because ace doesn't support this
        useWorker: window.location.protocol != 'file:'
      };
      // Default options if unspecified
      for (k in defaults) {
        if (options[k] == null)
          options[k] = defaults[k];
      }

      // Create el as relatively positioned div
      this.ojml = oj(function(){
        var input;
        if(args.length > 0)
          input = args.join('\n');
        oj.div(input, {
          style:{
            position:'relative',
            width:options.width,
            height:options.height
          }
        });
      });

      // AceEditor is must be included by <script> tag. Help people understand.
      if(oj.isClient && ace == null)
        throw new Error('oj.AceEditor: `ace` global not found. Include the editor with a <script> tag!');

      // Create editor
      if (oj.isClient && typeof ace != 'undefined') {

        this.editor = ace.edit(this.el);
        this.editor.resize()

        // Register for editor changes
        // Use debounce to ensure cut and paste only fires one event change
        var This = this;
        this.session.doc.on('change', debounce(50, function(){
          if (typeof This.viewChanged == 'function')
            This.viewChanged();
          if (typeof This.change == 'function')
            This.change();
        }));
      }

      // Shift editor properties
      var props = [
        'theme',
        'mode',
        'width',
        'height',
        'wrapLimit',
        'showPrintMargin',
        'readOnly',
        'fontSize',
        'tabSize',

        'foldStyle',
        'selectionStyle',

        'showPrintMargin',
        'showInvisibles',
        'showGutter',
        'showIndentGuides',
        'showFoldWidgets',

        'highlightSelectedWord',
        'highlightActiveLine',

        'useSoftTabs',
        'useWrapMode',
        'wrapLimitRange',
        'printMarginColumn',
        'animatedScroll',
        'useWorker',
        'hScrollBarAlwaysVisible',
        'fadeFoldWidgets',

        'behaviorsEnabled'
      ];
      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        if (options[prop] != null)
          this[prop] = oj.argumentShift(options, prop);
      }

      // Pass on options. Args have been handled at this level.
      AceEditor.base.constructor.apply(this, [options]);

    },

    properties: {

      // Accessing Properties
      // ----------------------------------------------------------------------

      value: {
        get: function(){ if(this.session) return this.session.getValue(); },
        set: function(v){
          if(this.session) {
            // Save the location of the cursor
            var pos = this.cursorPosition;
            this.session.setValue(v);
            // Restore the location of the cursor
            this.cursorPosition = pos;
          }
        }
      },

      editor: {
        get: function(){ return this._editor; },
        set: function(v){ this._editor = v; }
      },

      session: {
        get: function(){ if(this.editor) return this.editor.getSession(); },
        set: function(v){ if(this.editor) this.editor.setSession(v); }
      },

      renderer: {
        get: function(){ if(this.editor) return this.editor.renderer; }
      },

      change: {
        get: function(){ return this._change; },
        set: function(v){ this._change = v; }
      },

      // Wrap ace event handling object
      eventHandler: {
        get: function(){
          if (typeof 'ace' == 'undefined')
            return;
          return this._eventHandler || (this._eventHandler = ace.require("ace/lib/event"));
        }
      },

      // Wrap ace container element
      containerEl: {
        get: function(){
          return this._container || (this._container = this.$('.editor-container')[0]);
        }
      },

      // Custom Properties
      // ----------------------------------------------------------------------

      // Set/get theme and automatically add ace/theme prefix
      theme: {
        get: function(){
          if (!this.editor) return;
          var theme = this.editor.getTheme();
          var prefix = 'ace/theme/';
          if (theme && theme.indexOf(prefix) === 0)
            theme = theme.slice(prefix.length);
          return theme;
        },
        set: function(v){
          if (!this.editor) return;
          var prefix = 'ace/theme/';
          if (v && v.indexOf(prefix) != 0)
            v = prefix + v;
          this.editor.setTheme(v);
        }
      },

      // Set/get mode and automatically add ace/mode prefix
      mode: {
        get: function(){
          if (!this.session) return;
          // Get mode string from Mode object
          var mode = this.session.getMode().$id;
          var prefix = 'ace/mode/';
          if (mode && mode.indexOf(prefix) === 0)
            mode = mode.slice(prefix.length);
          return mode;
        },
        set: function(v){
          if (!this.session) return;
          var prefix = 'ace/mode/';
          if (v && v.indexOf(prefix) != 0)
            v = prefix + v;
          this.session.setMode(v);
        }
      },

      // Change width
      width: {
        get: function(){ return this.$el.css('width'); },
        set: function(v){
          this.$el.css('width', v);
          if (this.editor)
            this.editor.resize();
        }
      },

      // Change height
      height: {
        get: function(){ return this.$el.css('height'); },
        set: function(v){
          this.$el.css('height', v);
          if (this.editor)
            this.editor.resize();
        }
      },

      // Meta property that sets wrapLimitRange, printMarginColumn, and useWrapMode all at once
      // wrapLimit: 40      (limit of 40 characters)
      // wrapLimit: 'off'   (no limit, creates scroll bar)
      // wrapLimit: 'auto'  (limit to size of buffer)
      wrapLimit: {
        get: function(){ if(this.session) return this.wrapLimitRange; },
        set: function(v){
          if(this.session) {
            // Turn off wrapping if false or set to 'off'
            if(!v || v === 'off') {
              this.useWrapMode = false;
              this.printMarginColumn = 80;
            }

            // Wrap to region if set to 'auto'
            else if (v === 'auto') {
              this.useWrapMode = true;
              this.wrapLimitRange = null;
              this.printMarginColumn = 80;
            }

            // Otherwise wrap to specified character count
            else if (typeof v === 'number') {
              this.wrapLimitRange = v;
              this.printMarginColumn = v;
              this.useWrapMode = true;
            }
          }
        }
      },

      // TODO: Enable Drag and drop as a property
      // useDragAndDrop: {
      //   get: function(){},
      //   set: function(v){}
      // },
      // https://github.com/ajaxorg/ace/blob/master/demo/kitchen-sink/demo.js#L437
      // event.addListener(container, "drop", function(e) {
      //   var file;
      //   try {
      //       file = e.dataTransfer.files[0];
      //       if (window.FileReader) {
      //           var reader = new FileReader();
      //           reader.onload = function() {
      //               var mode = modelist.getModeFromPath(file.name);

      //               env.editor.session.doc.setValue(reader.result);
      //               modeEl.value = mode.name;
      //               env.editor.session.setMode(mode.mode);
      //               env.editor.session.modeName = mode.name;
      //           };
      //           reader.readAsText(file);
      //       }
      //       return event.preventDefault(e);
      //   } catch(err) {
      //       return event.stopEvent(e);
      //   }
      // });

      // Editor Configuration Properties
      // ----------------------------------------------------------------------

      // Make the editor read only
      readOnly: {
        get: function(){ if(this.editor) return this.editor.getReadOnly(); },
        set: function(v){ if(this.editor) this.editor.setReadOnly(v); }
      },

      // Change font size
      fontSize: {
        get: function(){ if(this.editor) return this._fontSize; },
        set: function(v){
          if(this.editor) {
            this.editor.setFontSize(v);
            this._fontSize = v;
          }
        }
      },

      // Change tab size
      tabSize: {
        get: function(){ if(this.editor) return this.session.getTabSize(); },
        set: function(v){ if(this.editor) this.session.setTabSize(v); }
      },

      // Change cursorPosition as object: {row:4, column:25}
      cursorPosition: {
        get: function(){ if(this.editor) return this.editor.getCursorPosition(); },
        set: function(v){ if(this.editor) this.editor.moveCursorToPosition(v); }
      },

      // Editor Show Properties
      // ----------------------------------------------------------------------

      // Show print margin
      showPrintMargin: {
        get: function(){ if(this.editor) return this.editor.getShowPrintMargin(); },
        set: function(v){ if(this.editor) this.editor.setShowPrintMargin(v); }
      },

      // Show invisible characters
      showInvisibles: {
        get: function(){ if(this.editor) return this.editor.getShowInvisibles(); },
        set: function(v){ if(this.editor) this.editor.setShowInvisibles(v); }
      },

      // Show gutter
      showGutter: {
        get: function(){ if(this.editor) return this.renderer.getShowGutter(); },
        set: function(v){ if(this.editor) this.renderer.setShowGutter(v); }
      },

      // Show Indent guides
      showIndentGuides: {
        get: function(){ if(this.editor) return this.editor.getDisplayIndentGuides(); },
        set: function(v){ if(this.editor) this.editor.setDisplayIndentGuides(v); }
      },

      // Show fold widgets that collapse / expand code blocks
      showFoldWidgets: {
        get: function(){ if(this.editor) return this.editor.getShowFoldWidgets(); },
        set: function(v){ if(this.editor) this.editor.setShowFoldWidgets(v); }
      },

      // Editor Highlight Properties
      // ----------------------------------------------------------------------

      // Highlight selected word elsewhere in the editor
      highlightSelectedWord: {
        get: function(){ if(this.editor) return this.editor.getHighlightSelectedWord(); },
        set: function(v){ if(this.editor) this.editor.setHighlightSelectedWord(v); }
      },

      // Highlight active line
      highlightActiveLine: {
        get: function(){ if(this.editor) return this.editor.getHighlightActiveLine(); },
        set: function(v){ if(this.editor) this.editor.setHighlightActiveLine(v); }
      },

      // Editor Style Properties
      // ----------------------------------------------------------------------

      // Selection style options: 'line' or 'text'
      selectionStyle: {
        get: function(){ if(this.editor) return this.editor.getSelectionStyle(); },
        set: function(v){ if(this.editor) this.editor.setSelectionStyle(v); }
      },

      // Fold style options: 'manual', markbegin' or 'markbeginend'
      foldStyle: {
        get: function(){ if(this.session) return this._foldStyle; },
        set: function(v){
          if(this.session) {
            this._foldStyle = v;
            this.session.setFoldStyle(v);
          }
        }
      },

      // Enable ace editor behaviors to auto match quotes, parens, curly braces, and square brackets
      behaviorsEnabled: {
        get: function(){ if(this.editor) return this.editor.getBehavioursEnabled(); },
        set: function(v){ if(this.editor) this.editor.setBehavioursEnabled(v); }
      },

      // Editor Not-Very-Important Properties
      // ----------------------------------------------------------------------------------

      useSoftTabs: {
        get: function(){ if(this.session) return this.session.getUseSoftTabs(); },
        set: function(v){ if(this.session) this.session.setUseSoftTabs(v); }
      },

      // Set whether wrapping should be on (true) or off (false)
      useWrapMode: {
        get: function(){ if(this.session) return this.session.getUseWrapMode(); },
        set: function(v){ if(this.session) this.session.setUseWrapMode(v); }
      },

      // Set the wrap limit character count
      wrapLimitRange: {
        get: function(){ if(this.session) return this.session.getWrapLimitRange(); },
        set: function(v){ if(this.session) this.session.setWrapLimitRange(v, v); },
      },

      // Set the number of characters the margin should appear at.
      printMarginColumn: {
        get: function(){ if(this.renderer) return this.renderer.getPrintMarginColumn(); },
        set: function(v){ if(this.renderer) this.renderer.setPrintMarginColumn(v); }
      },

      // Animates scrolling for find and goto line
      animatedScroll: {
        get: function(){ if(this.editor) return this.editor.getAnimatedScroll(); },
        set: function(v){ if(this.editor) this.editor.setAnimatedScroll(v); }
      },

      // Use or disable worker threads in ace editor
      useWorker: {
        get: function(){ if(this.session) return this.session.getUseWorker(); },
        set: function(v){ if(this.session) this.session.setUseWorker(v); }
      },

      // Turn horizontal scrollbar on permanently
      hScrollBarAlwaysVisible: {
        get: function(){ if(this.editor) return this.renderer.getHScrollBarAlwaysVisible(); },
        set: function(v){ if(this.editor) this.renderer.setHScrollBarAlwaysVisible(v); }
      },

      // Fade fold widgets that allow code blocks to be collapsed
      fadeFoldWidgets: {
        get: function(){ if(this.editor) return this.editor.getFadeFoldWidgets(); },
        set: function(v){ if(this.editor) this.editor.setFadeFoldWidgets(v); }
      }

    },

    methods: {
    }
  });

  return {AceEditor:AceEditor};

};

// Debounce from underscore to remove the only underscore dependency
// http://underscorejs.org/#debounce
debounce = function(wait, func, immediate) {
  var timeout, result;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) result = func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) result = func.apply(context, args);
    return result;
  };
};})(RR('/node_modules/oj-ace-editor/src/oj.AceEditor.js'),P,G,'/node_modules/oj-ace-editor/src','oj.AceEditor.js');});
F['/node_modules/oj-vimeo-video/src/oj.VimeoVideo.js'] = (function(module,exports){(function(require,process,global,__dirname,__filename){// Create a plugin by defining a function that accepts oj and
// returns a map of extensions to oj

// Froogaloop is the offical javascript api to Vimeo
// https://github.com/vimeo/player-api/tree/master/javascript
var Froogaloop=function(){function e(a){return new e.fn.init(a)}function h(a,c,b){if(!b.contentWindow.postMessage)return!1;var f=b.getAttribute("src").split("?")[0],a=JSON.stringify({method:a,value:c});"//"===f.substr(0,2)&&(f=window.location.protocol+f);b.contentWindow.postMessage(a,f)}function j(a){var c,b;try{c=JSON.parse(a.data),b=c.event||c.method}catch(f){}"ready"==b&&!i&&(i=!0);if(a.origin!=k)return!1;var a=c.value,e=c.data,g=""===g?null:c.player_id;c=g?d[g][b]:d[b];b=[];if(!c)return!1;void 0!==
a&&b.push(a);e&&b.push(e);g&&b.push(g);return 0<b.length?c.apply(null,b):c.call()}function l(a,c,b){b?(d[b]||(d[b]={}),d[b][a]=c):d[a]=c}var d={},i=!1,k="";e.fn=e.prototype={element:null,init:function(a){"string"===typeof a&&(a=document.getElementById(a));this.element=a;a=this.element.getAttribute("src");"//"===a.substr(0,2)&&(a=window.location.protocol+a);for(var a=a.split("/"),c="",b=0,f=a.length;b<f;b++){if(3>b)c+=a[b];else break;2>b&&(c+="/")}k=c;return this},api:function(a,c){if(!this.element||
!a)return!1;var b=this.element,f=""!==b.id?b.id:null,d=!c||!c.constructor||!c.call||!c.apply?c:null,e=c&&c.constructor&&c.call&&c.apply?c:null;e&&l(a,e,f);h(a,d,b);return this},addEvent:function(a,c){if(!this.element)return!1;var b=this.element,d=""!==b.id?b.id:null;l(a,c,d);"ready"!=a?h("addEventListener",a,b):"ready"==a&&i&&c.call(null,d);return this},removeEvent:function(a){if(!this.element)return!1;var c=this.element,b;a:{if((b=""!==c.id?c.id:null)&&d[b]){if(!d[b][a]){b=!1;break a}d[b][a]=null}else{if(!d[a]){b=
!1;break a}d[a]=null}b=!0}"ready"!=a&&b&&h("removeEventListener",a,c)}};e.fn.init.prototype=e.fn;window.addEventListener?window.addEventListener("message",j,!1):window.attachEvent("onmessage",j);return window.Froogaloop=e}();

// Create url from Vimeo options
function vimeoUrl(video, options)
{
  var out = 'http://player.vimeo.com/video/' + video + '?api=1&player_id=' + options.player_id;
  for(k in options)
    out += '&' + k + '=' + options[k];
  return out;
}

module.exports = function(oj,settings){
  if (typeof settings !== 'object')
    settings = {}

  var VimeoVideo = oj.type('VimeoVideo', {
    // The model-key bind to the url of the movie
    base: oj.View,

    // VimeoVideo(videoID, properties)
    constructor: function(){
      var this_ = this;
      var union = oj.argumentsUnion(arguments);
      var options = union.options;
      var args = union.args;

      var defaults = {
        width: 400,
        height: 224,
        color: '00adef'
      };

      // Default options if unspecified
      for (k in defaults) {
        if (options[k] == null)
          options[k] = defaults[k];
      }

      // First argument is video id
      if(args.length > 0)
        this.video = args[0];

      // Shift properties
      var props = [
        'video',
        'title',
        'byline',
        'portrait',
        'color',
        'autoplay',
        'loop'
      ];
      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        if (options[prop] != null)
          this[prop] = oj.argumentShift(options, prop);
      }

      this.ojml = oj(function(){
        oj.iframe({
          src: this_.src,
          frameborder:0,
          webkitAllowFullScreen:1,
          mozallowfullscreen:1,
          allowFullScreen:1,
        });
      });

      VimeoVideo.base.constructor.apply(this, [options]);

      // // // Bind events using javascript API
      // this.player = Froogaloop(this.el);

      // // // When the player is ready, add listeners for pause, finish, and playProgress
      // this.player.addEvent('ready', function() {});


      //   console.log("ready called");

      //   this_.player.addEvent('pause', function(){this_.onPause.apply(this_,arguments)});
      //   this_.player.addEvent('finish', function(){this_.onFinish.apply(this_,arguments)});
      //   this_.player.addEvent('playProgress', function(){this_.onPlayProgress.apply(this_,arguments)});
      // });

      // if (oj.isClient) {
      //   console.log("starting: ", starting);
      //   player.api('starting');
      // }
    },
    properties: {
      width: {
        get: function(){ return this.$el.attr('width'); },
        set: function(v){
          this.$el.attr('width', v);
        }
      },

      height: {
        get: function(){ return this.$el.attr('height'); },
        set: function(v){
          this.$el.attr('height', v);
        }
      },

      // The video id
      video: 24715531,

      // Show title (readwrite)
      title: false,

      // Show the users byline on the video (readwrite)
      byline: false,

      // Show the user's portrait on the video (readwrite)
      portrait: false,

      // Color of controls (readwrite)
      color: {
        get: function(){return this._color;},
        set: function(v){
          // Remove prefix of '#'
          if(v.length > 0 && v[0] == '#')
            v = v.slice(1);
          this._color = v;
        }
      },

      // Play the video automatically on load
      autoplay: false,

      // Repeat video when it reaches the end
      loop: false,

      src: {
        get: function(){
          return vimeoUrl(this.video, this.videoOptions);
        }
      },

      // Gather options to set url (readonly)
      videoOptions: {
        get: function(){
          return {
            title: (this.title ? 1 : 0),
            byline: (this.byline ? 1 : 0),
            portrait: (this.portrait ? 1 : 0),
            color: this.color,
            autoplay: (this.autoplay ? 1 : 0),
            loop: (this.loop ? 1 : 0),
            player_id: (this.id ? 1 : 0)
          };
        }
      }
    },

    methods: {

      play: function(){

      },
      stop: function(){

      },
      rewind: function(){

      },

      onPause: function(id) {
        console.log('paused', id);
      },

      onFinish: function(id) {
        console.log('finish', id);
      },

      onPlayProgress: function(data, id) {
        console.log('playProgress: ', data, id);
      }

    }
  });

  return {VimeoVideo:VimeoVideo};
};
})(RR('/node_modules/oj-vimeo-video/src/oj.VimeoVideo.js'),P,G,'/node_modules/oj-vimeo-video/src','oj.VimeoVideo.js');});
F['/node_modules/oj-twitter-follow-button/src/oj.TwitterFollowButton.js'] = (function(module,exports){(function(require,process,global,__dirname,__filename){// oj.TwitterFollowButton

// Load twitter api only once
var _loaded;

// Create plugin
module.exports = function(oj,settings){
  if (typeof settings !== 'object')
    settings = {}

  var TwitterFollowButton = oj.type('TwitterFollowButton', {

    base: oj.View,

    constructor: function(){
      var this_ = this;
      var union = oj.argumentsUnion(arguments);
      var options = union.options;
      var args = union.args;

      // First argument is username
      if(args.length > 0)
        this.username = args[0];

      // Shift properties
      var props = [
        'label',
        'large',
        'showCount',
        'showUsername',
        'username'
      ];
      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        if (options[prop] != null)
          this[prop] = oj.argumentShift(options, prop);
      }

      // Create el
      this.ojml = oj(function(){
        var size = null, tailor = null;
        if (this_.large)
          size = {'data-size':'large'};
        if (!this_.showTailoring)
          tailor = {'data-dnt':false};

        oj.a("Follow @" + this_.username, {
            href: 'https://twitter.com/' + this_.username,
            c:'twitter-follow-button',
            'data-show-count':this_.showCount,
            'data-show-screen-name':this_.showUsername,
            style:{display:'none'}
          },
          tailor,
          size
        );
      });

      TwitterFollowButton.base.constructor.apply(this, [options]);

      this.loadTwitterAPI();
    },
    properties: {
      username: 'evanmoran',

      showUsername: true,

      showCount: false,

      showTailoring: true,

      large: false
    },

    methods: {
      loadTwitterAPI:function(){
        var this_ = this;
        if (oj.isClient && !_loaded) {
          var p=/^http:/.test(document.location)?'http':'https';
          $.ajax({
            url: p + '://platform.twitter.com/widgets.js',
            dataType: "script",
            cached: true,
            // Show button once api has been called (avoids flickering)
            complete: function(){this_.$el.show()}
          });
        }
        _loaded = 1;
      }
    }
  });

  return {TwitterFollowButton:TwitterFollowButton};
};
})(RR('/node_modules/oj-twitter-follow-button/src/oj.TwitterFollowButton.js'),P,G,'/node_modules/oj-twitter-follow-button/src','oj.TwitterFollowButton.js');});
F['oj'] = (function(module,exports){(function(process,global,__dirname,__filename){// Generated by CoffeeScript 1.3.3
(function() {
  var ArrayP, FuncP, ObjP, boundOrThrow, coffee, compileJS, concat, exports, jqName, jqueryEvents, jqueryExtend, key, oj, ojName, pass, pathNormalizeArray, pathSplit, pathSplitRe, plugins, root, slice, stripBOM, t, unshift, wrapCSMessage, wrapJS, wrapJSMessage, _, _attributeCMeansClass, _attributeClassAllowsArrays, _attributeStyleAllowsObject, _attributesBindEventsToDOM, _attributesFilterOutEvents, _attributesFromObject, _attributesProcessedForOJ, _chars, _compileAny, _compileDeeper, _compileTag, _cssFromObject, _defaultClear, _fn, _fn1, _getInstanceOnElement, _getTagName, _i, _j, _len, _len1, _randomInteger, _readyOrLoad, _readyQueue, _ref, _ref1, _setInstanceOnElement, _setTagName, _styleFromObject, _styleKeyFromFancy, _tagAttributes,
    __slice = [].slice;

  oj = module.exports = function() {
    var ojml;
    _.argumentsPush();
    ojml = oj.emit.apply(this, arguments);
    _.argumentsPop();
    return ojml;
  };

  oj.emit = function() {
    var ojml;
    return ojml = oj.tag.apply(oj, ['oj'].concat(__slice.call(arguments)));
  };

  oj.oj = oj;

  oj.begin = function(page) {
    return _readyOrLoad(function() {
      var body, bodyOnly, d, dom, t, types, _i, _j, _len, _len1, _ref;
      bodyOnly = {
        html: 1,
        doctype: 1,
        head: 1,
        link: 1,
        script: 1
      };
      _ref = oj.compile({
        dom: 1,
        html: 0,
        css: 0,
        ignore: bodyOnly
      }, require(page)), dom = _ref.dom, types = _ref.types;
      if (!(dom != null)) {
        console.error('oj: dom failed to compile');
        return;
      }
      body = document.getElementsByTagName('body');
      if (body.length === 0) {
        console.error('oj: <body> was not found');
        return;
      }
      body = body[0];
      body.innerHTML = '';
      if (!oj.isArray(dom)) {
        dom = [dom];
      }
      for (_i = 0, _len = dom.length; _i < _len; _i++) {
        d = dom[_i];
        body.appendChild(d);
      }
      for (_j = 0, _len1 = types.length; _j < _len1; _j++) {
        t = types[_j];
        t.inserted();
      }
      return oj.ready();
    });
  };

  _readyOrLoad = function(fn) {
    var prevOnLoad;
    if (typeof $ !== "undefined" && $ !== null) {
      $(fn);
    } else {
      if (document.readyState !== "complete") {
        prevOnLoad = window.onload;
        window.onload = function() {
          if (typeof prevOnLoad === "function") {
            prevOnLoad();
          }
          return fn();
        };
      } else {
        fn();
      }
    }
  };

  _readyQueue = {
    queue: [],
    loaded: false
  };

  oj.ready = function(f) {
    if (oj.isUndefined(f)) {
      _readyQueue.loaded = true;
      while ((f = _readyQueue.queue.shift())) {
        f();
      }
    } else if (_readyQueue.loaded) {
      f();
    } else {
      _readyQueue.queue.push(f);
    }
  };

  oj.id = function(len, chars) {
    return 'oj' + oj.guid(len, chars);
  };

  _randomInteger = function(min, max) {
    var diff, rnd;
    if (min === null || max === null || min > max) {
      return null;
    }
    diff = max - min;
    rnd = Math.floor(Math.random() * (diff + 1));
    return rnd + min;
  };

  _chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split('');

  oj.guid = function(len, chars) {
    var base, charNext, charsPerRand, i, output, rand, randMax, randMin, _i;
    if (len == null) {
      len = 8;
    }
    if (chars == null) {
      chars = _chars;
    }
    base = chars.length;
    charsPerRand = Math.floor(Math.log(Math.pow(2, 31) - 1) / Math.log(base));
    randMin = 0;
    randMax = Math.pow(base, charsPerRand) - 1;
    output = "";
    for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
      if (i % charsPerRand === 0) {
        rand = _randomInteger(randMin, randMax);
      }
      charNext = chars[rand % base];
      output += charNext;
      rand = Math.floor(rand / base);
    }
    return output;
  };

  if (require.extensions) {
    coffee = require('coffee-script');
    stripBOM = function(c) {
      if (c.charCodeAt(0) === 0xFEFF) {
        return c.slice(1);
      } else {
        return c;
      }
    };
    wrapJS = function(code) {
      return "(function(){with(oj.sandbox){" + code + "}}).call(this);";
    };
    wrapCSMessage = function(message, filepath) {
      var _ref, _ref1;
      return "" + ((_ref = oj.codes) != null ? _ref.red : void 0) + "coffee-script error in " + filepath + ": " + message + ((_ref1 = oj.codes) != null ? _ref1.reset : void 0);
    };
    wrapJSMessage = function(message, filepath) {
      var _ref, _ref1;
      return "" + ((_ref = oj.codes) != null ? _ref.red : void 0) + "javascript error in " + filepath + ": " + message + ((_ref1 = oj.codes) != null ? _ref1.reset : void 0);
    };
    compileJS = function(module, code, filepath) {
      code = wrapJS(code);
      global.oj = oj;
      module._compile(code, filepath);
      return delete global.oj;
    };
    require.extensions['.oj'] = function(module, filepath) {
      var code;
      code = stripBOM(fs.readFileSync(filepath, 'utf8'));
      try {
        return compileJS(module, code, filepath);
      } catch (eJS) {
        eJS.message = wrapJSMessage(eJS.message, filepath);
        throw eJS;
      }
    };
    require.extensions['.ojc'] = function(module, filepath) {
      var code;
      code = stripBOM(fs.readFileSync(filepath, 'utf8'));
      try {
        code = coffee.compile(code, {
          bare: true
        });
      } catch (eCoffee) {
        eCoffee.message = wrapCSMessage(eCoffee.message, filepath);
        throw eCoffee;
      }
      try {
        return compileJS(module, code, filepath);
      } catch (eJS) {
        eJS.message = wrapJSMessage(eJS.message, filepath);
        throw eJS;
      }
    };
  }

  root = this;

  oj.version = '0.0.14';

  oj.isClient = true;

  if (typeof module !== 'undefined') {
    exports = module.exports = oj;
  } else {
    root['oj'] = oj;
  }

  oj.isUndefined = function(obj) {
    return obj === void 0;
  };

  oj.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  oj.isNumber = function(obj) {
    return !!(obj === 0 || (obj && obj.toExponential && obj.toFixed));
  };

  oj.isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  oj.isDate = function(obj) {
    return !!(obj && obj.getTimezoneOffset && obj.setUTCFullYear);
  };

  oj.isFunction = function(obj) {
    return typeof obj === 'function';
  };

  oj.isArray = Array.isArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  oj.isRegEx = function(obj) {
    return toString.call(obj) === '[object RegExp]';
  };

  oj.isDOM = function(obj) {
    return !!(obj && (obj.nodeType != null));
  };

  oj.isDOMElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  oj.isDOMAttribute = function(obj) {
    return !!(obj && obj.nodeType === 2);
  };

  oj.isDOMText = function(obj) {
    return !!(obj && obj.nodeType === 3);
  };

  oj.isjQuery = function(obj) {
    return !!(obj && obj.jquery);
  };

  oj.isEvented = function(obj) {
    return !!(obj && obj.on && obj.off && obj.trigger);
  };

  oj.isOJ = function(obj) {
    return !!(obj != null ? obj.isOJ : void 0);
  };

  oj.isArguments = function(obj) {
    return toString.call(obj) === '[object Arguments]';
  };

  oj.typeOf = function(any) {
    var t;
    if (any === null) {
      return 'null';
    }
    t = typeof any;
    if (t === 'object') {
      if (oj.isArray(any)) {
        t = 'array';
      } else if (oj.isOJ(any)) {
        t = any.typeName;
      } else if (oj.isRegEx(any)) {
        t = 'regexp';
      } else if (oj.isDate(any)) {
        t = 'date';
      } else if (oj.isDOMElement(any)) {
        t = 'dom-element';
      } else if (oj.isDOMText(any)) {
        t = 'dom-text';
      } else if (oj.isDOMAttribute(any)) {
        t = 'dom-attribute';
      } else if (oj.isjQuery(any)) {
        t = 'jquery';
      } else {
        t = 'object';
      }
    }
    return t;
  };

  oj.parse = function(str) {
    var number;
    if (str === 'undefined') {
      return void 0;
    } else if (str === 'null') {
      return null;
    } else if (str === 'true') {
      return true;
    } else if (str === 'false') {
      return false;
    } else if (!(isNaN(number = parseFloat(str)))) {
      return number;
    } else {
      return str;
    }
  };

  oj.isObject = function(obj) {
    return (oj.typeOf(obj)) === 'object';
  };

  ArrayP = Array.prototype;

  FuncP = Function.prototype;

  ObjP = Object.prototype;

  slice = ArrayP.slice;

  unshift = ArrayP.unshift;

  concat = ArrayP.concat;

  oj.__ = _ = {};

  _.isCapitalLetter = function(c) {
    return !!(c.match(/[A-Z]/));
  };

  _.identity = function(v) {
    return v;
  };

  _.property = function(obj, options) {
    if (options == null) {
      options = {};
    }
    return Object.defineProperty(obj, options);
  };

  _.has = function(obj, key) {
    return ObjP.hasOwnProperty.call(obj, key);
  };

  _.keys = Object.keys || function(obj) {
    var key, keys;
    if (obj !== Object(obj)) {
      throw 'Invalid object';
    }
    keys = [];
    for (key in obj) {
      if (_has(obj, key)) {
        keys[keys.length] = key;
      }
    }
    return keys;
  };

  _.values = function(obj) {
    var out;
    if (obj !== Object(obj)) {
      throw 'Invalid object';
    }
    out = [];
    _.each(obj, function(v) {
      return out.push(v);
    });
    return out;
  };

  _.flatten = function(array, shallow) {
    return _.reduce(array, (function(memo, value) {
      if (oj.isArray(value)) {
        return memo.concat(shallow ? value : _.flatten(value));
      }
      memo[memo.length] = value;
      return memo;
    }), []);
  };

  _.reduce = function(obj, iterator, memo, context) {
    var ctor, initial;
    if (obj == null) {
      obj = [];
    }
    initial = arguments.length > 2;
    if (ArrayP.reduce && obj.reduce === ArrayP.reduce) {
      if (context) {
        iterator = _.bind(iterator, context);
      }
      if (initial) {
        return obj.reduce(iterator, memo);
      } else {
        return obj.reduce(iterator);
      }
    }
    _.each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        return initial = true;
      } else {
        return memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    memo;

    ctor = function() {};
    return _.bind = function(func, context) {
      var args, bound;
      if (func.bind === FuncP.bind && FuncP.bind) {
        return FuncP.bind.apply(func, slice.call(arguments, 1));
      }
      if (!oj.isFunction(func)) {
        throw new TypeError;
      }
      args = slice.call(arguments, 2);
      return bound = function() {
        var result, self;
        if (!(this instanceof bound)) {
          return func.apply(context, args.concat(slice.call(arguments)));
        }
        ctor.prototype = func.prototype;
        self = new ctor;
        result = func.apply(self, args.concat(slice.call(arguments)));
        if (Object(result) === result) {
          return result;
        }
        return self;
      };
    };
  };

  _.sortedIndex = function(array, obj, iterator) {
    var high, low, mid;
    if (iterator == null) {
      iterator = _.identity;
    }
    low = 0;
    high = array.length;
    while (low < high) {
      mid = (low + high) >> 1;
      if (iterator(array[mid]) < iterator(obj)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return low;
  };

  _.indexOf = function(array, item, isSorted) {
    var i, v, _i, _len;
    if (array == null) {
      return -1;
    }
    if (isSorted) {
      i = _.sortedIndex(array, item);
      if (array[i] === item) {
        return i;
      } else {
        return -1;
      }
    }
    if (ArrayP.indexOf && array.indexOf === ArrayP.indexOf) {
      return array.indexOf(item);
    }
    for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
      v = array[i];
      if (v === item) {
        return i;
      }
    }
    return -1;
  };

  _.toArray = function(obj) {
    if (!obj) {
      return [];
    }
    if (oj.isArray(obj)) {
      return slice.call(obj);
    }
    if (oj.isArguments(obj)) {
      return slice.call(obj);
    }
    if (obj.toArray && oj.isFunction(obj.toArray)) {
      return obj.toArray();
    }
    return _.values(obj);
  };

  _.isEmpty = function(obj) {
    var k;
    if (oj.isArray(obj)) {
      return obj.length === 0;
    }
    for (k in obj) {
      if (_.has(obj, k)) {
        return false;
      }
    }
    return true;
  };

  _.clone = function(obj) {
    if (!oj.isObject(obj)) {
      return obj;
    }
    if (oj.isArray(obj)) {
      return obj.slice();
    } else {
      return _.extend({}, obj);
    }
  };

  _.contains = function(obj, target) {
    if (!(obj != null)) {
      return false;
    }
    if (ArrayP.indexOf && obj.indexOf === ArrayP.indexOf) {
      return obj.indexOf(target) !== -1;
    }
    return _.any(obj, function(value) {
      return value === target;
    });
  };

  _.some = _.any = function(obj, iterator, context) {
    var result;
    if (iterator == null) {
      iterator = _.identity;
    }
    result = false;
    if (!(obj != null)) {
      return result;
    }
    if (ArrayP.some && obj.some === ArrayP.some) {
      return obj.some(iterator, context);
    }
    _.each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) {
        return breaker;
      }
    });
    return !!result;
  };

  _.breaker = {};

  _.each = function(col, iterator, context) {
    var i, k, v, _i, _len;
    if (col === null) {
      return;
    }
    if (ArrayP.forEach && col.forEach === ArrayP.forEach) {
      return col.forEach(iterator, context);
    } else if (oj.isArray(col)) {
      for (i = _i = 0, _len = col.length; _i < _len; i = ++_i) {
        v = col[i];
        if (iterator.call(context, v, i, col) === _.breaker) {
          return _.breaker;
        }
      }
    } else {
      for (k in col) {
        v = col[k];
        if (_.has(col, k)) {
          if (iterator.call(context, v, k, col) === _.breaker) {
            return _.breaker;
          }
        }
      }
    }
  };

  _.map = function(obj, iterator, options) {
    var context, evaluate, iterator_, k, out, r, recurse, v;
    if (options == null) {
      options = {};
    }
    context = options.context;
    recurse = options.recurse;
    evaluate = options.evaluate;
    iterator_ = iterator;
    if (recurse) {
      (function(options) {
        return iterator_ = function(v, k, o) {
          var options_;
          options_ = _.extend(_.clone(options), {
            key: k,
            object: v
          });
          return _.map(v, iterator, options_);
        };
      })(options);
    }
    if (oj.isFunction(obj)) {
      if (!evaluate) {
        return obj;
      }
      while (evaluate && oj.isFunction(obj)) {
        obj = obj();
      }
    }
    out = obj;
    if (oj.isArray(obj)) {
      out = [];
      if (!obj) {
        return out;
      }
      if (ArrayP.map && obj.map === ArrayP.map) {
        return obj.map(iterator_, context);
      }
      _.each(obj, (function(v, ix, list) {
        return out[out.length] = iterator_.call(context, v, ix, list);
      }));
      if (obj.length === +obj.length) {
        out.length = obj.length;
      }
    } else if (oj.isObject(obj)) {
      out = {};
      if (!obj) {
        return out;
      }
      for (k in obj) {
        v = obj[k];
        if ((r = iterator_.call(context, v, k, obj)) !== void 0) {
          out[k] = r;
        }
      }
    } else {
      return iterator.call(context, obj, options.key, options.object);
    }
    return out;
  };

  _.extend = function(obj) {
    _.each(slice.call(arguments, 1), (function(source) {
      var key, value, _results;
      _results = [];
      for (key in source) {
        value = source[key];
        _results.push(obj[key] = value);
      }
      return _results;
    }));
    return obj;
  };

  _.defaults = function(obj) {
    _.each(slice.call(arguments, 1), (function(source) {
      var prop, _results;
      _results = [];
      for (prop in source) {
        if (!(obj[prop] != null)) {
          _results.push(obj[prop] = source[prop]);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }));
    return obj;
  };

  _.omit = function(obj) {
    var copy, key, keys;
    copy = {};
    keys = concat.apply(ArrayP, slice.call(arguments, 1));
    for (key in obj) {
      if (!_.contains(keys, key)) {
        copy[key] = obj[key];
      }
    }
    return copy;
  };

  _.uniqueSort = function(array, isSorted) {
    var item, ix, out, _i, _len;
    if (isSorted == null) {
      isSorted = false;
    }
    if (!isSorted) {
      array.sort();
    }
    out = [];
    for (ix = _i = 0, _len = array.length; _i < _len; ix = ++_i) {
      item = array[ix];
      if (ix > 0 && array[ix - 1] === array[ix]) {
        continue;
      }
      out.push(item);
    }
    return out;
  };

  _.uniqueSortedUnion = function(array, array2) {
    return _.uniqueSort(array.concat(array2));
  };

  _.debounce = function(wait, func, immediate) {
    var result, timeout;
    timeout = null;
    result = null;
    return function() {
      var args, callNow, context, later;
      context = this;
      args = arguments;
      later = function() {
        timeout = null;
        if (!immediate) {
          return result = func.apply(context, args);
        }
      };
      callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
      }
      return result;
    };
  };

  pathNormalizeArray = function(parts, allowAboveRoot) {
    var i, last, up;
    up = 0;
    i = parts.length - 1;
    while (i >= 0) {
      last = parts[i];
      if (last === '.') {
        parts.splice(i, 1);
      } else if (last === '..') {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
      i--;
    }
    if (allowAboveRoot) {
      while (up--) {
        parts.unshift('..');
      }
    }
    return parts;
  };

  pathSplitRe = /^(\/?)([\s\S]+\/(?!$)|\/)?((?:\.{1,2}$|[\s\S]+?)?(\.[^.\/]*)?)$/;

  pathSplit = function(filename) {
    var result;
    result = pathSplitRe.exec(filename);
    return [result[1] || '', result[2] || '', result[3] || '', result[4] || ''];
  };

  _.pathResolve = function() {
    var i, path, resolvedAbsolute, resolvedPath;
    resolvedPath = '';
    resolvedAbsolute = false;
    i = arguments.length - 1;
    while (i >= -1 && !resolvedAbsolute) {
      path = i >= 0 ? arguments[i] : process.cwd();
      if ((typeof path !== 'string') || !path) {
        continue;
      }
      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
      i--;
    }
    resolvedPath = pathNormalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');
    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  _.pathNormalize = function(path) {
    var isAbsolute, trailingSlash;
    isAbsolute = path.charAt(0) === '/';
    trailingSlash = path.substr(-1) === '/';
    path = pathNormalizeArray(path.split('/').filter(function(p) {
      return !!p;
    }), !isAbsolute).join('/');
    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }
    return (isAbsolute ? '/' : '') + path;
  };

  _.pathJoin = function() {
    var paths;
    paths = Array.prototype.slice.call(arguments, 0);
    return _.pathNormalize(paths.filter(function(p, index) {
      return p && typeof p === 'string';
    }).join('/'));
  };

  _.pathDirname = function(path) {
    var dir, result;
    result = pathSplit(path);
    root = result[0];
    dir = result[1];
    if (!root && !dir) {
      return '.';
    }
    if (dir) {
      dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
  };

  oj.addMethods = function(obj, mapNameToMethod) {
    var method, methodName;
    for (methodName in mapNameToMethod) {
      method = mapNameToMethod[methodName];
      oj.addMethod(obj, methodName, method);
    }
  };

  oj.addMethod = function(obj, methodName, method) {
    if (!oj.isString(methodName)) {
      throw 'oj.addMethod: string expected for second argument';
    }
    if (!oj.isFunction(method)) {
      throw 'oj.addMethod: function expected for thrid argument';
    }
    Object.defineProperty(obj, methodName, {
      value: method,
      enumerable: false,
      writable: false,
      configurable: true
    });
  };

  oj.removeMethod = function(obj, methodName) {
    if (!oj.isString(methodName)) {
      throw 'oj.removeMethod: string expected for second argument';
    }
    delete obj[methodName];
  };

  oj.addProperties = function(obj, mapNameToInfo) {
    var propInfo, propName;
    for (propName in mapNameToInfo) {
      propInfo = mapNameToInfo[propName];
      if (!((propInfo != null ? propInfo.get : void 0) != null) && !((propInfo != null ? propInfo.value : void 0) != null)) {
        propInfo = {
          value: propInfo,
          writable: true
        };
      }
      oj.addProperty(obj, propName, propInfo);
    }
  };

  oj.addProperty = function(obj, propName, propInfo) {
    if (!oj.isString(propName)) {
      throw 'oj.addProperty: string expected for second argument';
    }
    if (!(oj.isObject(propInfo))) {
      throw 'oj.addProperty: object expected for third argument';
    }
    _.defaults(propInfo, {
      enumerable: true,
      configurable: true
    });
    if (Object.getOwnPropertyDescriptor(obj, propName) != null) {
      oj.removeProperty(obj, propName);
    }
    Object.defineProperty(obj, propName, propInfo);
  };

  oj.removeProperty = function(obj, propName) {
    if (!oj.isString(propName)) {
      throw 'oj.addProperty: string expected for second argument';
    }
    return delete obj[propName];
  };

  oj.isProperty = function(obj, propName) {
    if (!oj.isString(propName)) {
      throw 'oj.isProperty: string expected for second argument';
    }
    return Object.getOwnPropertyDescriptor(obj, propName).get != null;
  };

  oj.copyProperty = function(dest, source, propName) {
    var info;
    info = Object.getOwnPropertyDescriptor(source, propName);
    return Object.defineProperty(dest, propName, info);
  };

  _.argumentsStack = [];

  oj.addProperty(_, 'arguments', {
    get: function() {
      if (_.argumentsStack.length) {
        return _.argumentsStack[_.argumentsStack.length - 1];
      } else {
        return null;
      }
    }
  });

  _.argumentsPush = function(args) {
    if (args == null) {
      args = [];
    }
    _.argumentsStack.push(args);
  };

  _.argumentsPop = function() {
    if (_.argumentsStack.length) {
      return _.argumentsStack.pop();
    }
    return null;
  };

  _.argumentsAppend = function(arg) {
    if (_["arguments"]) {
      _["arguments"].push(arg);
    }
  };

  oj.tag = function() {
    var arg, args, attributes, len, name, ojml, r, _i, _j, _len, _len1;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!oj.isString(name)) {
      throw 'oj.tag error: argument 1 is not a string (expected tag name)';
    }
    ojml = [name];
    attributes = {};
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      if (oj.isObject(arg)) {
        _.extend(attributes, arg);
      }
    }
    attributes = _tagAttributes(name, attributes);
    if (!_.isEmpty(attributes)) {
      ojml.push(attributes);
    }
    _.argumentsPush(ojml);
    for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
      arg = args[_j];
      if (oj.isObject(arg)) {
        continue;
      } else if (oj.isFunction(arg)) {
        len = _["arguments"].length;
        r = arg();
        if (len === _["arguments"].length && (r != null)) {
          _.argumentsAppend(r);
        }
      } else {
        _.argumentsAppend(arg);
      }
    }
    _.argumentsPop();
    _.argumentsAppend(ojml);
    return ojml;
  };

  oj.tag.elements = {
    closed: 'a abbr acronym address applet article aside audio b bdo big blockquote body button canvas caption center cite code colgroup command datalist dd del details dfn dir div dl dt em embed fieldset figcaption figure font footer form frameset h1 h2 h3 h4 h5 h6 head header hgroup html i iframe ins keygen kbd label legend li map mark menu meter nav noframes noscript object ol optgroup option output p pre progress q rp rt ruby s samp script section select small source span strike strong style sub summary sup table tbody td textarea tfoot th thead time title tr tt u ul var video wbr xmp'.split(' '),
    open: 'area base br col command css embed hr img input keygen link meta param source track wbr'.split(' ')
  };

  oj.tag.elements.all = (oj.tag.elements.closed.concat(oj.tag.elements.open)).sort();

  oj.tag.isClosed = function(tag) {
    return (_.indexOf(oj.tag.elements.open, tag, true)) === -1;
  };

  _setTagName = function(tag, name) {
    if (tag != null) {
      tag.tagName = name;
    }
  };

  _getTagName = function(tag) {
    return tag.tagName;
  };

  _getInstanceOnElement = function(el) {
    if ((el != null ? el.oj : void 0) != null) {
      return el.oj;
    } else {
      return null;
    }
  };

  _setInstanceOnElement = function(el, inst) {
    if (el != null) {
      el.oj = inst;
    }
  };

  _ref = oj.tag.elements.all;
  _fn = function(t) {
    oj[t] = function() {
      return oj.tag.apply(oj, [t].concat(__slice.call(arguments)));
    };
    return _setTagName(oj[t], t);
  };
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    t = _ref[_i];
    _fn(t);
  }

  _defaultClear = function(dest, d, e) {
    var k;
    _.defaults(dest, d);
    for (k in e) {
      delete dest[k];
    }
    return dest;
  };

  _tagAttributes = function(name, attributes) {
    var attr;
    attr = _.clone(attributes);
    switch (name) {
      case 'link':
        _defaultClear(attr, {
          rel: 'stylesheet',
          type: 'text/css',
          href: attr.url || attr.src
        }, {
          url: 0,
          src: 0
        });
        break;
      case 'script':
        _defaultClear(attr, {
          type: 'text/javascript',
          src: attr.url
        }, {
          url: 0
        });
        break;
      case 'a':
        _defaultClear(attr, {
          href: attr.url
        }, {
          url: 0
        });
    }
    return attr;
  };

  oj.page = function(options, content) {
    if (!(content != null)) {
      content = options;
      options = {};
    }
    return oj.html(function() {
      oj.head(function() {
        if (options.title != null) {
          return oj.title(options.title);
        }
      });
      return oj.body(function() {
        return content();
      });
    });
  };

  oj.extend = function(context) {
    var k, o, v;
    o = {};
    for (k in oj) {
      v = oj[k];
      if (k[0] !== '_') {
        o[k] = v;
      }
    }
    delete o.extend;
    return _.extend(context, o);
  };

  oj.compile = function(options, ojml) {
    var acc, css, cssMap, dom, html, out;
    if (!(ojml != null)) {
      ojml = options;
      options = {};
    }
    options = _.defaults({}, options, {
      html: true,
      dom: true,
      css: true,
      cssMap: false,
      debug: false,
      ignore: {}
    });
    _.extend(options.ignore, {
      oj: 1,
      css: 1
    });
    acc = _.clone(options);
    acc.html = options.html ? [] : null;
    acc.dom = options.dom && (typeof document !== "undefined" && document !== null) ? document.createElement('OJ') : null;
    acc.css = options.css || options.cssMap ? {} : null;
    acc.indent = '';
    if (options.dom) {
      acc.types = [];
    }
    acc.tags = {};
    _compileAny(ojml, acc);
    if (options.cssMap) {
      cssMap = acc.css;
    }
    if (options.css) {
      css = _cssFromObject(acc.css, options.debug);
    }
    if (options.html) {
      html = acc.html.join('');
    }
    if (options.dom) {
      dom = acc.dom.childNodes;
      if (dom.length != null) {
        dom = _.toArray(dom);
        dom = dom.filter(function(v) {
          return oj.isDOM(v);
        });
      }
      if (dom.length === 0) {
        dom = null;
      } else if (dom.length === 1) {
        dom = dom[0];
      }
    }
    out = {
      html: html,
      dom: dom,
      css: css,
      cssMap: cssMap,
      types: acc.types,
      tags: acc.tags
    };
    return out;
  };

  _styleKeyFromFancy = function(key) {
    var c, out, _j, _len1;
    out = "";
    for (_j = 0, _len1 = key.length; _j < _len1; _j++) {
      c = key[_j];
      if (_.isCapitalLetter(c)) {
        out += "-" + (c.toLowerCase());
      } else {
        out += c;
      }
    }
    return out;
  };

  _styleFromObject = function(obj, options) {
    var indent, ix, k, kFancy, keys, newline, out, semi, _j, _len1;
    if (options == null) {
      options = {};
    }
    _.defaults(options, {
      inline: true,
      indent: false
    });
    options.semi = !options.inline;
    out = "";
    keys = _.keys(obj).sort();
    indent = options.indent ? '\t' : '';
    newline = options.inline ? '' : '\n';
    for (ix = _j = 0, _len1 = keys.length; _j < _len1; ix = ++_j) {
      kFancy = keys[ix];
      semi = options.semi || ix !== keys.length - 1 ? ";" : '';
      k = _styleKeyFromFancy(kFancy);
      out += "" + indent + k + ":" + obj[kFancy] + semi + newline;
    }
    return out;
  };

  _attributesFromObject = function(obj) {
    var k, out, space, v, _j, _len1, _ref1;
    if (!oj.isObject(obj)) {
      return obj;
    }
    out = '';
    space = '';
    _ref1 = _.keys(obj).sort();
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      k = _ref1[_j];
      if ((v = obj[k]) != null) {
        out += "" + space + k + "=\"" + v + "\"";
      }
      space = ' ';
    }
    return out;
  };

  _cssFromObject = function(cssMap, isDebug) {
    var css, indent, inline, newline, rules, selector, space, styles;
    if (isDebug == null) {
      isDebug = 0;
    }
    newline = isDebug ? '\n' : '';
    space = isDebug ? ' ' : '';
    inline = !isDebug;
    indent = isDebug;
    css = '';
    for (selector in cssMap) {
      styles = cssMap[selector];
      rules = _styleFromObject(styles, {
        inline: inline,
        indent: indent
      });
      css += "" + selector + space + "{" + newline + rules + "}" + newline;
    }
    return css;
  };

  _compileDeeper = function(method, ojml, options) {
    var i;
    i = options.indent;
    options.indent += '\t';
    method(ojml, options);
    return options.indent = i;
  };

  pass = function() {};

  _compileAny = function(ojml, options) {
    var els, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    switch (oj.typeOf(ojml)) {
      case 'array':
        _compileTag(ojml, options);
        break;
      case 'jquery':
        if ((_ref1 = options.html) != null) {
          _ref1.push(ojml.html());
        }
        if ((_ref2 = options.dom) != null) {
          _ref2.concat(ojml.get());
        }
        break;
      case 'string':
        if ((_ref3 = options.html) != null) {
          _ref3.push(ojml);
        }
        if (ojml.length > 0 && ojml[0] === '<') {
          root = document.createElement('div');
          root.innerHTML = ojml;
          els = root.childNodes;
          if ((_ref4 = options.dom) != null) {
            _ref4.appendChild(root);
          }
        } else {
          if ((_ref5 = options.dom) != null) {
            _ref5.appendChild(document.createTextNode(ojml));
          }
        }
        break;
      case 'boolean':
      case 'number':
        if ((_ref6 = options.html) != null) {
          _ref6.push("" + ojml);
        }
        if ((_ref7 = options.dom) != null) {
          _ref7.appendChild(document.createTextNode("" + ojml));
        }
        break;
      case 'function':
        _compileAny(oj(ojml), options);
        break;
      case 'date':
        if ((_ref8 = options.html) != null) {
          _ref8.push("" + (ojml.toLocaleString()));
        }
        if ((_ref9 = options.dom) != null) {
          _ref9.appendChild(document.createTextNode("" + (ojml.toLocaleString())));
        }
        break;
      case 'null':
        break;
      case 'undefined':
        break;
      case 'object':
        break;
      default:
        if (oj.isOJ(ojml)) {
          if ((_ref10 = options.types) != null) {
            _ref10.push(ojml);
          }
          if ((_ref11 = options.html) != null) {
            _ref11.push(ojml.toHTML());
          }
          if ((_ref12 = options.dom) != null) {
            _ref12.appendChild(ojml.toDOM());
          }
          if (options.css != null) {
            _.extend(options.css, ojml.toCSSMap());
          }
        }
    }
  };

  jqueryEvents = {
    bind: 1,
    on: 1,
    off: 1,
    live: 1,
    blur: 1,
    change: 1,
    click: 1,
    dblclick: 1,
    focus: 1,
    focusin: 1,
    focusout: 1,
    hover: 1,
    keydown: 1,
    keypress: 1,
    keyup: 1,
    mousedown: 1,
    mouseenter: 1,
    mousemove: 1,
    mouseout: 1,
    mouseup: 1,
    ready: 1,
    resize: 1,
    scroll: 1,
    select: 1
  };

  _compileTag = function(ojml, options) {
    var attr, attrName, attrValue, attributes, child, children, el, events, selector, space, styles, tag, tagType, _base, _j, _k, _len1, _len2, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    if (ojml.length === 0) {
      return;
    }
    tag = ojml[0];
    tagType = typeof tag;
    tag = (tagType === 'function' || tagType === 'object') && (_getTagName(tag) != null) ? _getTagName(tag) : tag;
    if (!(oj.isString(tag) && tag.length > 0)) {
      throw new Error('oj.compile: tag name is missing');
    }
    if (_.isCapitalLetter(tag[0])) {
      return _compileDeeper(_compileAny, new oj[tag](ojml.slice(1)), options);
    }
    options.tags[tag] = true;
    attributes = null;
    if (oj.isObject(ojml[1])) {
      attributes = ojml[1];
    }
    children = attributes ? ojml.slice(2) : ojml.slice(1);
    if (options.css && tag === 'css') {
      for (selector in attributes) {
        styles = attributes[selector];
        if ((_ref1 = (_base = options.css)[selector]) == null) {
          _base[selector] = styles;
        }
        _.extend(options.css[selector], styles);
      }
    }
    if (!options.ignore[tag]) {
      events = _attributesProcessedForOJ(attributes);
      if (options.dom && (typeof document !== "undefined" && document !== null)) {
        el = document.createElement(tag);
        if (oj.isDOMElement(options.dom)) {
          options.dom.appendChild(el);
        }
        options.dom = el;
        if (oj.isObject(attributes)) {
          _ref2 = _.keys(attributes).sort();
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            attrName = _ref2[_j];
            attrValue = attributes[attrName];
            el.setAttribute(attrName, attrValue);
          }
        }
        _attributesBindEventsToDOM(events, el);
      }
      if (options.html) {
        attr = (_ref3 = _attributesFromObject(attributes)) != null ? _ref3 : '';
        space = attr === '' ? '' : ' ';
        options.html.push("<" + tag + space + attr + ">");
      }
    }
    for (_k = 0, _len2 = children.length; _k < _len2; _k++) {
      child = children[_k];
      if (options.debug && children.length > 1) {
        if ((_ref4 = options.html) != null) {
          _ref4.push("\n\t" + options.indent);
        }
      }
      _compileDeeper(_compileAny, child, options);
    }
    if (options.debug && children.length > 1) {
      if ((_ref5 = options.html) != null) {
        _ref5.push("\n" + options.indent);
      }
    }
    if (!options.ignore[tag]) {
      if (options.html && (children.length > 0 || oj.tag.isClosed(tag))) {
        if ((_ref6 = options.html) != null) {
          _ref6.push("</" + tag + ">");
        }
      }
      if (options.dom) {
        options.dom = options.dom.parentNode;
      }
    }
  };

  _attributeStyleAllowsObject = function(attr) {
    if (oj.isObject(attr != null ? attr.style : void 0)) {
      attr.style = _styleFromObject(attr.style, {
        inline: true
      });
    }
  };

  _attributeCMeansClass = function(attr) {
    if ((attr != null ? attr.c : void 0) != null) {
      attr["class"] = attr.c;
      delete attr.c;
    }
  };

  _attributeClassAllowsArrays = function(attr) {
    if (oj.isArray(attr != null ? attr["class"] : void 0)) {
      attr["class"] = attr.join(' ');
    }
  };

  _attributesFilterOutEvents = function(attr) {
    var k, out, v;
    out = {};
    if (oj.isObject(attr)) {
      for (k in attr) {
        v = attr[k];
        if (jqueryEvents[k] != null) {
          out[k] = v;
          delete attr[k];
        }
      }
    }
    return out;
  };

  _attributesProcessedForOJ = function(attr) {
    var events;
    _attributeCMeansClass(attr);
    _attributeStyleAllowsObject(attr);
    _attributeClassAllowsArrays(attr);
    events = _attributesFilterOutEvents(attr);
    return events;
  };

  _attributesBindEventsToDOM = function(events, el) {
    var ek, ev, _results;
    _results = [];
    for (ek in events) {
      ev = events[ek];
      if (typeof $ !== "undefined" && $ !== null) {
        if (oj.isArray(ev)) {
          _results.push($(el)[ek].apply(this, ev));
        } else {
          _results.push($(el)[ek](ev));
        }
      } else {
        _results.push(console.error("oj: jquery is missing when binding a '" + ek + "' event"));
      }
    }
    return _results;
  };

  oj.toHTML = function(options, ojml) {
    if (!oj.isObject(options)) {
      ojml = options;
      options = {};
    }
    _.extend(options, {
      dom: false,
      js: false,
      html: true,
      css: false
    });
    return (oj.compile(options, ojml)).html;
  };

  oj.toCSS = function(options, ojml) {
    if (!oj.isObject(options)) {
      ojml = options;
      options = {};
    }
    _.extend(options, {
      dom: false,
      js: false,
      html: false,
      css: true
    });
    return (oj.compile(options, ojml)).css;
  };

  _.inherit = function(child, parent) {
    var ctor, key;
    for (key in parent) {
      oj.copyProperty(child, parent, key);
    }
    ctor = function() {};
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.base = parent.prototype;
  };

  oj.argumentShift = function(args, key) {
    var value;
    if ((oj.isObject(args)) && (key != null) && (args[key] != null)) {
      value = args[key];
      delete args[key];
    }
    return value;
  };

  oj.type = function(name, args) {
    var Out, delay, methodKeys, methods, propKeys, properties, typeProps, _ref1, _ref2;
    if (args == null) {
      args = {};
    }
    if (!oj.isString(name)) {
      throw 'oj.type: string expected for first argument';
    }
    if (!oj.isObject(args)) {
      throw 'oj.type: object expected for second argument';
    }
    if ((_ref1 = args.methods) == null) {
      args.methods = {};
    }
    if ((_ref2 = args.properties) == null) {
      args.properties = {};
    }
    delay = '__DELAYED__';
    Out = new Function("return function " + name + "(){\n  var _this = this;\n  if ( !(this instanceof " + name + ") ) {\n    _this = new " + name + "('" + delay + "');\n    _this.__autonew__ = true;\n  }\n\n  if (arguments && arguments[0] != '" + delay + "')\n    " + name + ".prototype.constructor.apply(_this, arguments);\n\n  return _this;\n}")();
    if ((args.base != null) && ((!(args.constructor != null)) || (!args.hasOwnProperty('constructor')))) {
      args.constructor = function() {
        var _ref3;
        return (_ref3 = Out.base) != null ? _ref3.constructor.apply(this, arguments) : void 0;
      };
    }
    if (args.base != null) {
      _.inherit(Out, args.base);
    }
    oj.addMethod(Out.prototype, 'constructor', args.constructor);
    typeProps = {
      type: {
        value: Out,
        writable: false,
        enumerable: false
      },
      typeName: {
        value: name,
        writable: false,
        enumerable: false
      },
      isOJ: {
        value: true,
        writable: false,
        enumerable: false
      }
    };
    oj.addProperties(Out, typeProps);
    oj.addProperties(Out.prototype, typeProps);
    propKeys = (_.keys(args.properties)).sort();
    if (Out.prototype.properties != null) {
      propKeys = _.uniqueSortedUnion(Out.prototype.properties, propKeys);
    }
    properties = {
      value: propKeys,
      writable: false,
      enumerable: false
    };
    oj.addProperty(Out.prototype, 'properties', properties);
    methodKeys = (_.keys(args.methods)).sort();
    if (Out.prototype.methods != null) {
      methodKeys = _.uniqueSortedUnion(Out.prototype.methods, methodKeys);
    }
    methods = {
      value: methodKeys,
      writable: false,
      enumerable: false
    };
    oj.addProperty(Out.prototype, 'methods', methods);
    _.extend(args.methods, {
      get: function(k) {
        var out, p, _j, _len1, _ref3;
        if (oj.isString(k)) {
          if (this.has(k)) {
            return this[k];
          } else {
            return void 0;
          }
        } else {
          out = {};
          _ref3 = this.properties;
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            p = _ref3[_j];
            out[p] = this[p];
          }
          return out;
        }
      },
      set: function(k, v) {
        var key, obj, value;
        obj = k;
        if (!oj.isObject(k)) {
          obj = {};
          obj[k] = v;
        }
        for (key in obj) {
          value = obj[key];
          if (this.has(key)) {
            this[key] = value;
          }
        }
      },
      has: function(k) {
        return _.some(this.properties, function(v) {
          return v === k;
        });
      },
      can: function(k) {
        return _.some(this.methods, function(v) {
          return v === k;
        });
      },
      toJSON: function() {
        var json, prop, _j, _len1, _ref3;
        json = {};
        _ref3 = this.properties;
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          prop = _ref3[_j];
          json[prop] = this[prop];
        }
        return json;
      }
    });
    oj.addMethods(Out.prototype, args.methods);
    oj.addProperties(Out.prototype, args.properties);
    return Out;
  };

  oj.argumentsUnion = function(argList) {
    var list, obj, v, _j, _len1;
    obj = {};
    list = [];
    for (_j = 0, _len1 = argList.length; _j < _len1; _j++) {
      v = argList[_j];
      if (oj.isObject(v)) {
        obj = _.extend(obj, v);
      } else {
        list.push(v);
      }
    }
    return {
      options: obj,
      args: list
    };
  };

  oj["enum"] = function(name, args) {
    throw 'NYI';
  };

  oj.View = oj.type('View', {
    constructor: function(options) {
      var _ref1;
      if (options == null) {
        options = {};
      }
      if (!oj.isDOM(this.el)) {
        throw new Error("oj." + this.typeName + ": constructor failed to set this.el");
      }
      _setInstanceOnElement(this.el, this);
      if (this.__autonew__) {
        this.emit();
      }
      if ((_ref1 = options.id) == null) {
        options.id = oj.id();
      }
      this.$el.addClass("oj-" + this.typeName);
      this.set(options);
      options = _.omit.apply(_, [options].concat(__slice.call(this.properties)));
      this.addAttributes(options);
      return this._isConstructed = true;
    },
    properties: {
      ojml: {
        get: function() {
          return this._ojml;
        },
        set: function(v) {
          var _ref1;
          this._ojml = v;
          return _ref1 = oj.compile({
            css: 0,
            cssMap: 1,
            dom: 1,
            html: 0
          }, v), this.el = _ref1.dom, this.cssMap = _ref1.cssMap, _ref1;
        }
      },
      el: {
        get: function() {
          return this._el;
        },
        set: function(v) {
          this._el = v;
          this._$el = null;
        }
      },
      $el: {
        get: function() {
          var _ref1;
          return (_ref1 = this._$el) != null ? _ref1 : (this._$el = $(this.el));
        }
      },
      attributes: {
        get: function() {
          var out;
          out = {};
          $.each(this.el.attributes, function(index, attr) {
            return out[attr.name] = attr.value;
          });
          return out;
        }
      },
      id: {
        get: function() {
          return this.$el.attr('id');
        },
        set: function(v) {
          return this.$el.attr('id', v);
        }
      },
      cssMap: {
        get: function() {
          var _ref1;
          return (_ref1 = this._cssMap) != null ? _ref1 : {};
        },
        set: function(v) {
          return this._cssMap = v;
        }
      },
      isConstructed: {
        get: function() {
          var _ref1;
          return (_ref1 = this._isConstructed) != null ? _ref1 : false;
        }
      },
      isInserted: {
        get: function() {
          var _ref1;
          return (_ref1 = this._isInserted) != null ? _ref1 : false;
        }
      }
    },
    methods: {
      $: function() {
        var _ref1;
        return (_ref1 = this.$el).find.apply(_ref1, arguments);
      },
      addAttribute: function(name, value) {
        var attr;
        attr = {};
        attr[name] = value;
        return this.addAttributes(attr);
      },
      addAttributes: function(attributes) {
        var attr, events, k, v;
        attr = _.clone(attributes);
        events = _attributesProcessedForOJ(attr);
        if (oj.isObject(attr)) {
          for (k in attr) {
            v = attr[k];
            if (k === 'class') {
              this.$el.addClass(v);
            } else {
              this.$el.attr(k, v);
            }
          }
        }
        if (events != null) {
          _attributesBindEventsToDOM(events, this.el);
        }
      },
      removeAttribute: function(name) {
        this.$el.removeAttr(name);
      },
      removeAttributes: function(list) {
        var k, _j, _len1;
        for (_j = 0, _len1 = list.length; _j < _len1; _j++) {
          k = list[_j];
          this.removeAttribute(k);
        }
      },
      emit: function() {
        _.argumentsAppend(this);
      },
      toHTML: function(options) {
        return this.el.outerHTML + ((options != null ? options.debug : void 0) ? '\n' : '');
      },
      toDOM: function() {
        return this.el;
      },
      toCSS: function(debug) {
        return _cssFromObject(this.cssMap, debug);
      },
      toCSSMap: function() {
        return this.cssMap;
      },
      toString: function() {
        return this.toHTML();
      },
      inserted: function() {
        return this._isInserted = true;
      }
    }
  });

  oj.CollectionView = oj.type('CollectionView', {
    base: oj.View,
    constructor: function(options) {
      if ((options != null ? options.each : void 0) != null) {
        this.each = oj.argumentShift(options, 'each');
      }
      if ((options != null ? options.models : void 0) != null) {
        this.models = oj.argumentShift(options, 'models');
      }
      oj.CollectionView.base.constructor.apply(this, arguments);
      return this.make();
    },
    properties: {
      each: {
        get: function() {
          return this._each;
        },
        set: function(v) {
          this._each = v;
          if (this.isConstructed) {
            this.make();
          }
        }
      },
      models: {
        get: function() {
          return this._models;
        },
        set: function(v) {
          var _ref1, _ref2;
          if (oj.isFunction((_ref1 = this._models) != null ? _ref1.off : void 0)) {
            this._models.off('add remove change reset destroy', null, this);
          }
          this._models = v;
          if (oj.isFunction((_ref2 = this._models) != null ? _ref2.on : void 0)) {
            this._models.on('add', this.collectionAdded, this);
            this._models.on('remove', this.collectionRemoved, this);
            this._models.on('change', this.collectionChanged, this);
            this._models.on('reset', this.collectionReset, this);
            this._models.on('destroy', this.collectionDestroyed, this);
          }
          if (this.isConstructed) {
            this.make();
          }
        }
      }
    },
    methods: {
      make: function() {
        throw "oj." + typeName + ": make not implemented";
      },
      collectionAdded: function(model, collection) {
        return this.make();
      },
      collectionRemoved: function(model, collection, options) {
        return this.make();
      },
      collectionReset: function(collection, options) {
        return this.make();
      },
      collectionChanged: function(model, collection, options) {},
      collectionDestroyed: function(collection, options) {
        return this.make();
      }
    }
  });

  oj.ModelView = oj.type('ModelView', {
    base: oj.View,
    constructor: function(options) {
      if ((options != null ? options.value : void 0) != null) {
        this.value = oj.argumentShift(options, 'value');
      }
      if ((options != null ? options.model : void 0) != null) {
        this.model = oj.argumentShift(options, 'model');
      }
      return oj.ModelView.base.constructor.apply(this, arguments);
    },
    properties: {
      model: {
        get: function() {
          return this._model;
        },
        set: function(v) {
          if (oj.isEvented(this._model)) {
            this._model.off('change', null, this);
          }
          this._model = v;
          if (oj.isEvented(this._model)) {
            this._model.on('change', this.modelChanged, this);
          }
          this.modelChanged();
        }
      }
    },
    methods: {
      modelChanged: function() {
        var _this = this;
        return this.$el.oj(function() {
          return _this.make(_this.mode);
        });
      },
      make: function(model) {
        throw "oj." + this.typeName + ": make not implemented";
      }
    }
  });

  oj.ModelKeyView = oj.type('ModelKeyView', {
    base: oj.ModelView,
    constructor: function(options) {
      if ((options != null ? options.key : void 0) != null) {
        this.key = oj.argumentShift(options, 'key');
      }
      return oj.ModelKeyView.base.constructor.apply(this, arguments);
    },
    properties: {
      key: null,
      value: {
        get: function() {
          throw "" + this.typeName + " value getter not implemented";
        },
        set: function(v) {
          throw "" + this.typeName + " value setter not implemented";
        }
      }
    },
    methods: {
      modelChanged: function() {
        if ((this.model != null) && (this.key != null)) {
          if (!this._viewUpdatedModel) {
            this.value = this.model.get(this.key);
          }
        }
      },
      viewChanged: function() {
        var _this = this;
        setTimeout((function() {
          if ((_this.model != null) && (_this.key != null)) {
            _this._viewUpdatedModel = true;
            _this.model.set(_this.key, _this.value);
            _this._viewUpdatedModel = false;
          }
        }), 10);
      }
    }
  });

  oj.TextBox = oj.type('TextBox', {
    base: oj.ModelKeyView,
    constructor: function() {
      var args, options, _ref1,
        _this = this;
      _ref1 = oj.argumentsUnion(arguments), options = _ref1.options, args = _ref1.args;
      this.ojml = oj(function() {
        return oj.input({
          type: 'text'
        }, {
          keydown: function() {
            if (_this.live) {
              _this.viewChanged();
            }
          },
          keyup: function() {
            if (_this.live) {
              _this.viewChanged();
            }
          },
          change: function() {
            _this.viewChanged();
          }
        });
      });
      if (args.length > 0) {
        this.value = args[0];
      }
      if ((options != null ? options.live : void 0) != null) {
        this.live = oj.argumentShift(options, 'live');
      }
      return oj.TextBox.base.constructor.apply(this, [options]);
    },
    properties: {
      value: {
        get: function() {
          var v;
          v = this.el.value;
          if (!(v != null) || v === 'undefined') {
            v = '';
          }
          return v;
        },
        set: function(v) {
          this.el.value = v;
        }
      },
      live: true
    }
  });

  oj.CheckBox = oj.type('CheckBox', {
    base: oj.ModelKeyView,
    constructor: function() {
      var args, options, _ref1,
        _this = this;
      _ref1 = oj.argumentsUnion(arguments), options = _ref1.options, args = _ref1.args;
      this.ojml = oj(function() {
        return oj.input({
          type: 'checkbox'
        }, {
          change: function() {
            _this.viewChanged();
          }
        });
      });
      if (args.length > 0) {
        this.value = args[0];
      }
      return oj.CheckBox.base.constructor.call(this, options);
    },
    properties: {
      value: {
        get: function() {
          return this.el.checked;
        },
        set: function(v) {
          v = !!v;
          this.el.checked = v;
          if (v) {
            this.$el.attr('checked', 'checked');
          } else {
            this.$el.removeAttr('checked');
          }
        }
      }
    }
  });

  oj.TextArea = oj.type('TextArea', {
    base: oj.ModelKeyView,
    constructor: function() {
      var args, options, _ref1,
        _this = this;
      _ref1 = oj.argumentsUnion(arguments), options = _ref1.options, args = _ref1.args;
      this.ojml = oj(function() {
        return oj.textarea({
          keydown: function() {
            if (_this.live) {
              _this.viewChanged();
            }
          },
          keyup: function() {
            if (_this.live) {
              _this.viewChanged();
            }
          },
          change: function() {
            _this.viewChanged();
          }
        });
      });
      if (args.length > 0) {
        this.value = args[0];
      }
      return oj.TextArea.base.constructor.call(this, options);
    },
    properties: {
      value: {
        get: function() {
          return this.el.value;
        },
        set: function(v) {
          this.el.value = v;
        }
      },
      live: true
    }
  });

  oj.ListBox = oj.type('ListBox', {
    base: oj.ModelKeyView,
    constructor: function() {
      var args, options, _ref1,
        _this = this;
      _ref1 = oj.argumentsUnion(arguments), options = _ref1.options, args = _ref1.args;
      this.ojml = oj(function() {
        return oj.select({
          change: function() {
            _this.viewChanged();
          }
        });
      });
      this.options = oj.argumentShift(options, 'options');
      if (args.length > 0) {
        this.value = args[0];
      }
      return oj.ListBox.base.constructor.apply(this, [options]);
    },
    properties: {
      value: {
        get: function() {
          return this.$el.val();
        },
        set: function(v) {
          this.$el.val(v);
        }
      },
      options: {
        get: function() {
          return this._options;
        },
        set: function(v) {
          if (!oj.isArray(v)) {
            throw new Error('oj.ListBox::options array is missing');
          }
          this._options = v;
          this.$el.oj(function() {
            var op, _j, _len1;
            for (_j = 0, _len1 = v.length; _j < _len1; _j++) {
              op = v[_j];
              oj.option(op);
            }
          });
        }
      }
    }
  });

  oj.Button = oj.type('Button', {
    base: oj.View,
    constructor: function(args) {
      var options, _ref1, _ref2,
        _this = this;
      _ref1 = oj.argumentsUnion(arguments), options = _ref1.options, args = _ref1.args;
      if ((_ref2 = options.label) == null) {
        options.label = args.length > 0 ? args[0] : '';
      }
      this.ojml = oj(function() {
        return oj.button(options.label);
      });
      return oj.Button.base.constructor.apply(this, [options]);
    }
  });

  boundOrThrow = function(ix, count, message) {
    var ixNew;
    ixNew = ix < 0 ? ix + count : ix;
    if (!(0 <= ixNew && ixNew < count)) {
      throw new Error(message + (" is out of bounds (" + ix + " in [0," + (count - 1) + "])"));
    }
    return ixNew;
  };

  oj.List = oj.type('List', {
    base: oj.CollectionView,
    constructor: function() {
      var args, items, options, _ref1, _ref2,
        _this = this;
      _ref1 = oj.argumentsUnion(arguments), options = _ref1.options, args = _ref1.args;
      this._tagName = oj.argumentShift(options, 'tagName');
      this.itemTagName = oj.argumentShift(options, 'itemTagName');
      this.ojml = oj(function() {
        return oj[_this.tagName]();
      });
      if (options.el != null) {
        this.el = oj.argumentShift(options, 'el');
      }
      if ((_ref2 = options.each) == null) {
        options.each = function(model) {
          if ((oj.isString(model)) || (oj.isNumber(model)) || (oj.isBoolean(model))) {
            return model;
          } else {
            return JSON.stringify(model);
          }
        };
      }
      oj.List.base.constructor.apply(this, [options]);
      items = args.length > 0 ? args : null;
      return this.items = options.items != null ? oj.argumentShift(options, 'items') : items;
    },
    properties: {
      items: {
        get: function() {
          var v;
          if (this._items != null) {
            return this._items;
          }
          v = this.$itemsEl.ojValue();
          if (oj.isArray(v)) {
            return v;
          } else {
            return [v];
          }
        },
        set: function(v) {
          this._items = v;
          this.make();
        }
      },
      count: {
        get: function() {
          return this.$itemsEl.length;
        }
      },
      tagName: {
        get: function() {
          var _ref1;
          return (_ref1 = this._tagName) != null ? _ref1 : 'div';
        }
      },
      itemTagName: {
        get: function() {
          var _ref1;
          return (_ref1 = this._itemTagName) != null ? _ref1 : 'div';
        },
        set: function(v) {
          this._itemTagName = v;
          this.make();
        }
      },
      itemsEl: {
        get: function() {
          return this.$itemsEl.get();
        }
      },
      $itemsEl: {
        get: function() {
          var _ref1;
          return (_ref1 = this._$itemsEl) != null ? _ref1 : (this._$itemsEl = this.$("> " + this.itemTagName));
        }
      }
    },
    methods: {
      item: function(ix, ojml) {
        ix = boundOrThrow(ix, this.count, "oj.List.item: index");
        if (ojml != null) {
          this.$itemEl(ix).oj(ojml);
        } else {
          return this.$itemEl(ix).ojValue();
        }
      },
      itemEl: function(ix) {
        ix = boundOrThrow(ix, this.count, "oj.List.itemEl: index");
        return this.$itemsEl[ix];
      },
      $itemEl: function(ix) {
        ix = boundOrThrow(ix, this.count, "oj.List.$itemEl: index");
        return this.$itemsEl.eq(ix);
      },
      make: function() {
        var model, models, views, _j, _len1,
          _this = this;
        if (!this.isConstructed) {
          return;
        }
        views = [];
        if ((this.models != null) && (this.each != null)) {
          models = oj.isEvented(this._models) ? this._models.models : this._models;
          for (_j = 0, _len1 = models.length; _j < _len1; _j++) {
            model = models[_j];
            views.push(this._itemFromModel(model));
          }
        } else if (this.items != null) {
          views = this.items;
        }
        this.$el.oj(function() {
          var view, _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = views.length; _k < _len2; _k++) {
            view = views[_k];
            _results.push(_this._itemElFromItem(view));
          }
          return _results;
        });
        this.itemsChanged();
      },
      _itemFromModel: function(model) {
        var _this = this;
        return oj(function() {
          return _this.each(model);
        });
      },
      _itemElFromItem: function(item) {
        return oj[this.itemTagName](item);
      },
      add: function(ix, ojml) {
        var tag;
        if (arguments.length === 1) {
          ojml = ix;
          ix = this.count;
        }
        ix = boundOrThrow(ix, this.count + 1, "oj.List.add: index");
        tag = this.itemTagName;
        if (this.count === 0) {
          this.$el.oj(function() {
            return oj[tag](ojml);
          });
        } else if (ix === this.count) {
          this.$itemEl(ix - 1).ojAfter(function() {
            return oj[tag](ojml);
          });
        } else {
          this.$itemEl(ix).ojBefore(function() {
            return oj[tag](ojml);
          });
        }
        this.itemsChanged();
      },
      remove: function(ix) {
        var out;
        if (ix == null) {
          ix = -1;
        }
        ix = boundOrThrow(ix, this.count, "oj.List.remove: index");
        out = this.item(ix);
        this.$itemEl(ix).remove();
        this.itemsChanged();
        return out;
      },
      move: function(ixFrom, ixTo) {
        if (ixTo == null) {
          ixTo = -1;
        }
        if (ixFrom === ixTo) {
          return;
        }
        ixFrom = boundOrThrow(ixFrom, this.count, "oj.List.move: fromIndex");
        ixTo = boundOrThrow(ixTo, this.count, "oj.List.move: toIndex");
        if (ixTo > ixFrom) {
          this.$itemEl(ixFrom).insertAfter(this.$itemEl(ixTo));
        } else {
          this.$itemEl(ixFrom).insertBefore(this.$itemEl(ixTo));
        }
        this.itemsChanged();
      },
      swap: function(ix1, ix2) {
        var ixMax, ixMin;
        if (ix1 === ix2) {
          return;
        }
        ix1 = boundOrThrow(ix1, this.count, "oj.List.swap: firstIndex");
        ix2 = boundOrThrow(ix2, this.count, "oj.List.swap: secondIndex");
        if (Math.abs(ix1 - ix2) === 1) {
          this.move(ix1, ix2);
        } else {
          ixMin = Math.min(ix1, ix2);
          ixMax = Math.max(ix1, ix2);
          this.move(ixMax, ixMin);
          this.move(ixMin + 1, ixMax);
        }
        this.itemsChanged();
      },
      unshift: function(v) {
        this.add(0, v);
      },
      shift: function() {
        return this.remove(0);
      },
      push: function(v) {
        this.add(v);
      },
      pop: function() {
        return this.remove(-1);
      },
      clear: function() {
        this.$itemsEl.remove();
        this.itemsChanged();
      },
      itemsChanged: function() {
        this._$itemsEl = null;
      },
      collectionAdded: function(m, c) {
        var item, ix;
        ix = c.indexOf(m);
        item = this._itemFromModel(m);
        this.add(ix, item);
      },
      collectionRemoved: function(m, c, o) {
        this.remove(o.index);
      },
      collectionReset: function() {
        this.make();
      }
    }
  });

  oj.NumberList = function() {
    var _ref1;
    return (_ref1 = oj.List).call.apply(_ref1, [this, {
      tagName: 'ol',
      itemTagName: 'li'
    }].concat(__slice.call(arguments)));
  };

  oj.BulletList = function() {
    var _ref1;
    return (_ref1 = oj.List).call.apply(_ref1, [this, {
      tagName: 'ul',
      itemTagName: 'li'
    }].concat(__slice.call(arguments)));
  };

  oj.sandbox = {};

  _ref1 = _.keys(oj);
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    key = _ref1[_j];
    if (key.length > 0 && key[0] !== '_') {
      oj.addProperty(oj.sandbox, key, {
        value: oj[key],
        writable: false
      });
    }
  }

  oj.use = function(plugin, settings) {
    var name, pluginMap, value, _results;
    if (settings == null) {
      settings = {};
    }
    if (!oj.isFunction(plugin)) {
      throw new Error('oj.use: function expected for first argument');
    }
    if (!oj.isObject(settings)) {
      throw new Error('oj.use: object expected for second argument');
    }
    pluginMap = plugin(oj, settings);
    _results = [];
    for (name in pluginMap) {
      value = pluginMap[name];
      oj[name] = value;
      _results.push(oj.addProperty(oj.sandbox, name, {
        value: value,
        writable: false
      }));
    }
    return _results;
  };

  jqueryExtend = function(options) {
    if (options == null) {
      options = {};
    }
    _.defaults(options, {
      get: _.identity,
      set: _.identity
    });
    return function() {
      var $els, args, el, out, r, _k, _l, _len2, _len3;
      args = _.toArray(arguments);
      $els = $(this);
      if ((oj.isFunction(options.get)) && args.length === 0) {
        out = [];
        for (_k = 0, _len2 = $els.length; _k < _len2; _k++) {
          el = $els[_k];
          out.push(options.get($(el)));
        }
        if (out.length === 1) {
          return out[0];
        }
        return out;
      } else if (oj.isFunction(options.set)) {
        out = $els;
        for (_l = 0, _len3 = $els.length; _l < _len3; _l++) {
          el = $els[_l];
          r = options.set($(el), args);
          if (r != null) {
            return r;
          }
        }
        return $els;
      }
    };
  };

  $.fn.oj = jqueryExtend({
    set: function($el, args) {
      var d, dom, types, _k, _l, _len2, _len3, _ref2;
      if (args.length === 0) {
        return $el[0].oj;
      }
      _ref2 = oj.compile.apply(oj, [{
        dom: 1,
        html: 0,
        css: 0
      }].concat(__slice.call(args))), dom = _ref2.dom, types = _ref2.types;
      $el.html('');
      if (!oj.isArray(dom)) {
        dom = [dom];
      }
      for (_k = 0, _len2 = dom.length; _k < _len2; _k++) {
        d = dom[_k];
        $el.append(d);
      }
      for (_l = 0, _len3 = types.length; _l < _len3; _l++) {
        t = types[_l];
        t.inserted();
      }
    },
    get: function($el) {
      return $el[0].oj;
    }
  });

  $.fn.ojValue = jqueryExtend({
    set: null,
    get: function($el, args) {
      var child, el, inst, text;
      el = $el[0];
      child = el.firstChild;
      switch (oj.typeOf(child)) {
        case 'dom-text':
          return text = child.nodeValue;
        case 'dom-element':
          if ((inst = _getInstanceOnElement(child)) != null) {
            return inst;
          } else {
            return child;
          }
      }
    }
  });

  plugins = {
    ojAfter: 'after',
    ojBefore: 'before',
    ojAppend: 'append',
    ojPrepend: 'prepend',
    ojReplaceWith: 'replaceWith',
    ojWrap: 'wrap',
    ojWrapInner: 'wrapInner'
  };

  _fn1 = function(ojName, jqName) {
    return $.fn[ojName] = jqueryExtend({
      set: function($el, args) {
        var dom, types, _k, _len2, _ref2;
        _ref2 = oj.compile.apply(oj, [{
          dom: 1,
          html: 0
        }].concat(__slice.call(args))), dom = _ref2.dom, types = _ref2.types;
        $el[jqName](dom);
        for (_k = 0, _len2 = types.length; _k < _len2; _k++) {
          t = types[_k];
          t.inserted();
        }
      },
      get: null
    });
  };
  for (ojName in plugins) {
    jqName = plugins[ojName];
    _fn1(ojName, jqName);
  }

}).call(this);
})(P,G,'/','oj');});

P = {cwd: function(){return '/';}};
G = {process: P,Buffer: {}};
RR = function(f){
  return function(m){
    return run(find(m, f));
  };
  function run(f){
    if(R[f] != null)
      return R[f];
    var eo = {},
      mo = {exports: eo};
    if(typeof F[f] != 'function')
      throw new Error("file not found (" + f + ")");
    F[f](mo,eo);
    return R[f] = mo.exports;
  }
  function find(m,f){
    var r, dir, dm, ext, ex, i;

    if (F[m] && !m.match(/\//)) {
      return m;
    }

    if (!!m.match(/\//)) {
      r = oj.__.pathResolve(f, oj.__.pathJoin(oj.__.pathDirname(f), m));
      ext = ['.ojc','.oj','.coffee','.js','.json'];
      for(i = 0; i < ext.length; i++){
        ex = ext[i];
        if(F[r+ex])
          return r+ex;
      }
    } else {
      dir = oj.__.pathDirname(f);
      while(true) {
        dm = oj.__.pathJoin(dir, 'node_modules');
        if(M[dm] && M[dm][m])
          return oj.__.pathJoin(dm, m, M[dm][m]);
        if(dir == '/')
          break;
        dir = oj.__.pathResolve(dir, '..');
      }
    }
    throw new Error("module not found (" + m + ")");
  }
};

require = RR('/test');
oj = require('oj');
oj.begin('/test');

}).call(this);

</script></body>
</html>
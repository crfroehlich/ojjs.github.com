<html lang="en">
	
	<head>
		<link href="styles/reset.css" rel="stylesheet" type="text/css">
		<script src="scripts/jquery.js" type="text/javascript"></script>
		<script src="scripts/coffee-script.js" type="text/javascript"></script>
		<script src="scripts/ace/ace.js" type="text/javascript"></script>
		<meta charset="UTF-8">
		<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
		<title>Try OJ</title>
	<style>
h1 {
	color:#666;
	font-family:Lucida Grande, Tahoma;
	font-size:24px;
	font-weight:lighter;
	letter-spacing:0.2em;
	margin-bottom:12px;
	margin-top:6px;
	text-transform:uppercase;
}
h2 {
	color:#666;
	font-family:Lucida Grande, Tahoma;
	font-size:18px;
	font-weight:lighter;
	letter-spacing:0.2em;
	margin-bottom:9px;
	margin-top:6px;
	text-transform:uppercase;
}
h3 {
	color:#666;
	font-family:Lucida Grande, Tahoma;
	font-size:14px;
	font-weight:lighter;
	letter-spacing:0.2em;
	margin-bottom:3px;
	margin-top:3px;
	text-transform:uppercase;
}
h4 {
	color:#666;
	font-family:Lucida Grande, Tahoma;
	font-size:12px;
	font-weight:lighter;
	letter-spacing:0.2em;
	margin-bottom:3px;
	margin-top:3px;
}
p {
	color:#222;
	font-family:Lucida Grande, Tahoma;
	font-size:14px;
	font-weight:lighter;
	letter-spacing:0.5 em;
	margin-bottom:12px;
}
ul {
	margin:0px 0px 22px 30px;
}
li {
	margin:0px 0px 4px 0px;
}
textarea {
	border-color:#f4f4f4;
	font-family:Lucida Grande, Tahoma;
	font-size:14px;
	height:100px;
	width:100%;
}
.snippet {
	border:1px solid #orange;
	height:100px;
	margin:0;
	position:relative;
	width:100%;
}
.editor-source {
	background-color:#fefaf3;
	border:2px solid #fbcb7c;
	box-shadow:2px 2px 4px RGBA(0,0,0,0.15);
	display:block;
	height:30%;
	padding:10px;
	position:relative;
	width:100%;
}
.editor-source-cs {
	display:block;
	height:100%;
	width:100%;
}
.editor-source-cs.hidden {
	display:none;
}
.editor-source-js {
	display:block;
	height:100%;
	width:100%;
}
.editor-source-js.hidden {
	display:none;
}
.editor-source-css {
	display:block;
	height:100%;
	width:100%;
}
.editor-source-html {
	display:block;
	height:100%;
	width:100%;
}
.editor-frame {
	display:block;
	height:65%;
	position:relative;
	width:100%;
}
.editor-iframe {
	display:block;
	height:100%;
	width:100%;
}
.editor-console {
	background-color:RGBA(255,255,255,0.9);
	color:darkorange;
	font-size:18px;
	height:100%;
	left:0;
	margin:0px 0px 10px 0px;
	padding:14px 4px;
	position:absolute;
	text-align:center;
	top:0;
	width:100%;
}
.editor-resizer {
	background-color:#FFBA4D;
	height:10px;
	width:100%;
	z-index:10;
}
.editor-bar {
	height:21px;
	margin:8px 8px 0 0;
	position:absolute;
	right:0px;
	top:0px;
	z-index:5;
}
.editor-example-chooser {
	float:right;
	font-size:20px;
	height:100%;
	margin-left:8px;
	position:relative;
	z-index:10;
}
.editor-language-tab {
	background-color:white;
	border:1px solid gray;
	border-radius:3px;
	display:inline-block;
	float:right;
	height:100%;
	margin-left:0px;
	width:30px;
	z-index:10;
}
.editor-language-tab.selected {
	background-color:#FECD78;
}

</style></head>
	<body><div class="editor">
			
			<div class="editor-bar">
				<select class="editor-example-chooser">
					<option value="0"></option>
					<option value="1">Headers and Paragraphs</option>
					<option value="2">Markdown</option>
					<option value="3">Defining ID and Class</option>
					<option value="4">Tags with Inline Styles</option>
					<option value="5">Tags with Click Events</option>
					<option value="6">Tags with Several Attributes</option>
					<option value="7">Create a Checkbox</option>
					<option value="8">Create a TextBox</option>
					<option value="9">Create a TextArea</option>
					<option value="10">Creating a Template</option>
					<option value="11">Create a Partial</option>
					<option value="12">Create a Table</option>
					<option value="13">Create a Table Partial</option>
				</select>
				<button class="editor-language-tab js">JS</button>
				<button class="selected editor-language-tab cs">CS</button>
			</div>
			<div class="editor-source">
				<div class="editor-source-cs" id="ojjI8tEjXA"></div>
				<div class="editor-source-js hidden" id="oj4fS4XHQf"></div>
			</div>
			<div class="editor-frame">
				<div class="editor-console"></div>
				<iframe class="editor-iframe"></iframe>
			</div>
		</div><script>

// Generated with oj v0.0.8
(function(){ var F = {}, M = {}, R = {}, P, G, RR;

M['/node_modules'] = {"underscore":"underscore.js","oj-markdown":"src/oj.markdown.js"};
M['/node_modules/oj-markdown/node_modules'] = {"marked":"lib/marked.js"};
F['/try.ojc'] = (function(module,exports){(function(require,process,global,__dirname,__filename){(function(){with(require('oj').sandbox){var siteCSS, _, _editor, _snippet;

_ = require('underscore');

oj.use(require('oj-markdown'));

siteCSS = require('./_styles');

_snippet = require('./_snippet');

_editor = require('./_editor');

module.exports = html({
  lang: 'en'
}, function() {
  siteCSS();
  head(function() {
    link({
      url: 'styles/reset.css'
    });
    script({
      url: 'scripts/jquery.js'
    });
    script({
      url: 'scripts/coffee-script.js'
    });
    script({
      url: 'scripts/ace/ace.js'
    });
    meta({
      charset: 'UTF-8'
    });
    meta({
      'http-equiv': "X-UA-Compatible",
      content: 'IE=edge,chrome=1'
    });
    return title('Try OJ');
  });
  return body(function() {
    return _editor("");
  });
});
}}).call(this);})(RR('/try.ojc'),P,G,'/','try.ojc');});
F['/node_modules/underscore/underscore.js'] = (function(module,exports){(function(require,process,global,__dirname,__filename){//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    if (obj.length === +obj.length) results.length = obj.length;
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var shuffled = [], rand;
    each(obj, function(value, index, list) {
      rand = Math.floor(Math.random() * (index + 1));
      shuffled[index] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, val, context) {
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      if (a === void 0) return 1;
      if (b === void 0) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    var result = {};
    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value);
    });
    return result;
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj)                                     return [];
    if (_.isArray(obj))                           return slice.call(obj);
    if (_.isArguments(obj))                       return slice.call(obj);
    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.isArray(obj) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especcialy useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var results = [];
    // The `isSorted` flag is irrelevant if the array only contains two elements.
    if (array.length < 3) isSorted = true;
    _.reduce(initial, function (memo, value, index) {
      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
        memo.push(value);
        results.push(array[index]);
      }
      return memo;
    }, []);
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays. (Aliased as "intersect" for back-compat.)
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = _.flatten(slice.call(arguments, 1), true);
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (i in array && array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, throttling, more, result;
    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
    return function() {
      context = this; args = arguments;
      var later = function() {
        timeout = null;
        if (more) func.apply(context, args);
        whenDone();
      };
      if (!timeout) timeout = setTimeout(later, wait);
      if (throttling) {
        more = true;
      } else {
        result = func.apply(context, args);
      }
      whenDone();
      throttling = true;
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      if (immediate && !timeout) func.apply(context, args);
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) { return func.apply(this, arguments); }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var result = {};
    each(_.flatten(slice.call(arguments, 1)), function(key) {
      if (key in obj) result[key] = obj[key];
    });
    return result;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function.
  function eq(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  }

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return toString.call(obj) == '[object Arguments]';
  };
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given value a function?
  _.isFunction = function(obj) {
    return toString.call(obj) == '[object Function]';
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return toString.call(obj) == '[object String]';
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
  };

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return toString.call(obj) == '[object Date]';
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return toString.call(obj) == '[object RegExp]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Has own property?
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
  };

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    '\\': '\\',
    "'": "'",
    'r': '\r',
    'n': '\n',
    't': '\t',
    'u2028': '\u2028',
    'u2029': '\u2029'
  };

  for (var p in escapes) escapes[escapes[p]] = p;
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(unescaper, function(match, escape) {
      return escapes[escape];
    });
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults(settings || {}, _.templateSettings);

    // Compile the template source, taking care to escape characters that
    // cannot be included in a string literal and then unescape them in code
    // blocks.
    var source = "__p+='" + text
      .replace(escaper, function(match) {
        return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function(match, code) {
        return "'+\n_.escape(" + unescape(code) + ")+\n'";
      })
      .replace(settings.interpolate || noMatch, function(match, code) {
        return "'+\n(" + unescape(code) + ")+\n'";
      })
      .replace(settings.evaluate || noMatch, function(match, code) {
        return "';\n" + unescape(code) + "\n;__p+='";
      }) + "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __p='';" +
      "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
      source + "return __p;\n";

    var render = new Function(settings.variable || 'obj', '_', source);
    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for build time
    // precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
      source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var wrapped = this._wrapped;
      method.apply(wrapped, arguments);
      var length = wrapped.length;
      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
      return result(wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

}).call(this);
})(RR('/node_modules/underscore/underscore.js'),P,G,'/node_modules/underscore','underscore.js');});
F['/node_modules/oj-markdown/src/oj.markdown.js'] = (function(module,exports){(function(require,process,global,__dirname,__filename){var marked = require('marked');
// Create a plugin by defining a function that accepts oj and returns a map of extensions to oj
module.exports = function(oj,settings){
  // Initialize marked options
  if (typeof settings !== 'object')
    settings = {}
  marked.setOptions(settings);

  // oj.markdown
  return {markdown:function(input){
    return oj(marked(input));
  }};
};})(RR('/node_modules/oj-markdown/src/oj.markdown.js'),P,G,'/node_modules/oj-markdown/src','oj.markdown.js');});
F['/node_modules/oj-markdown/node_modules/marked/lib/marked.js'] = (function(module,exports){(function(require,process,global,__dirname,__filename){/**
 * marked - a markdown parser
 * Copyright (c) 2011-2013, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){3,} *\n*/,
  blockquote: /^( *>[^\n]+(\n[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', /\n+(?=(?: *[-*_]){3,} *(?:\n+|$))/)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\w+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!' + block.gfm.fences.source.replace('\\1', '\\2') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'list_start',
        ordered: isFinite(cap[2])
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      // Get bullet.
      if (this.options.smartLists) {
        bull = block.bullet.exec(cap[0])[0];
      }

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i+1])[0];
          if (bull !== b && !(bull[1] === '.' && b[1] === '.')) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item[item.length-1] === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre',
        text: cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1][cap[1].length-1] === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([^\s]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1][6] === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += '<a href="'
        + href
        + '">'
        + text
        + '</a>';
      continue;
    }

    // url (gfm)
    if (cap = this.rules.url.exec(src)) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += '<a href="'
        + href
        + '">'
        + text
        + '</a>';
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0][0];
        src = cap[0].substring(1) + src;
        continue;
      }
      out += this.outputLink(cap, link);
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<strong>'
        + this.output(cap[2] || cap[1])
        + '</strong>';
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<em>'
        + this.output(cap[2] || cap[1])
        + '</em>';
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<code>'
        + escape(cap[2], true)
        + '</code>';
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<br>';
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<del>'
        + this.output(cap[1])
        + '</del>';
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(cap[0]);
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  if (cap[0][0] !== '!') {
    return '<a href="'
      + escape(link.href)
      + '"'
      + (link.title
      ? ' title="'
      + escape(link.title)
      + '"'
      : '')
      + '>'
      + this.output(cap[1])
      + '</a>';
  } else {
    return '<img src="'
      + escape(link.href)
      + '" alt="'
      + escape(cap[1])
      + '"'
      + (link.title
      ? ' title="'
      + escape(link.title)
      + '"'
      : '')
      + '>';
  }
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options) {
  var parser = new Parser(options);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length-1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return '<hr>\n';
    }
    case 'heading': {
      return '<h'
        + this.token.depth
        + '>'
        + this.inline.output(this.token.text)
        + '</h'
        + this.token.depth
        + '>\n';
    }
    case 'code': {
      if (this.options.highlight) {
        var code = this.options.highlight(this.token.text, this.token.lang);
        if (code != null && code !== this.token.text) {
          this.token.escaped = true;
          this.token.text = code;
        }
      }

      if (!this.token.escaped) {
        this.token.text = escape(this.token.text, true);
      }

      return '<pre><code'
        + (this.token.lang
        ? ' class="'
        + this.options.langPrefix
        + this.token.lang
        + '"'
        : '')
        + '>'
        + this.token.text
        + '</code></pre>\n';
    }
    case 'table': {
      var body = ''
        , heading
        , i
        , row
        , cell
        , j;

      // header
      body += '<thead>\n<tr>\n';
      for (i = 0; i < this.token.header.length; i++) {
        heading = this.inline.output(this.token.header[i]);
        body += this.token.align[i]
          ? '<th align="' + this.token.align[i] + '">' + heading + '</th>\n'
          : '<th>' + heading + '</th>\n';
      }
      body += '</tr>\n</thead>\n';

      // body
      body += '<tbody>\n'
      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];
        body += '<tr>\n';
        for (j = 0; j < row.length; j++) {
          cell = this.inline.output(row[j]);
          body += this.token.align[j]
            ? '<td align="' + this.token.align[j] + '">' + cell + '</td>\n'
            : '<td>' + cell + '</td>\n';
        }
        body += '</tr>\n';
      }
      body += '</tbody>\n';

      return '<table>\n'
        + body
        + '</table>\n';
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return '<blockquote>\n'
        + body
        + '</blockquote>\n';
    }
    case 'list_start': {
      var type = this.token.ordered ? 'ol' : 'ul'
        , body = '';

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return '<'
        + type
        + '>\n'
        + body
        + '</'
        + type
        + '>\n';
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return '<li>'
        + body
        + '</li>\n';
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return '<li>'
        + body
        + '</li>\n';
    }
    case 'html': {
      return !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
    }
    case 'paragraph': {
      return '<p>'
        + this.inline.output(this.token.text)
        + '</p>\n';
    }
    case 'text': {
      return '<p>'
        + this.parseText()
        + '</p>\n';
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}

/**
 * Marked
 */

function marked(src, opt) {
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-'
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());
})(RR('/node_modules/oj-markdown/node_modules/marked/lib/marked.js'),P,G,'/node_modules/oj-markdown/node_modules/marked/lib','marked.js');});
F['/_styles.ojc'] = (function(module,exports){(function(require,process,global,__dirname,__filename){(function(){with(require('oj').sandbox){
module.exports = function() {
  return css({
    h1: {
      fontFamily: 'Lucida Grande, Tahoma',
      fontSize: '24px',
      fontWeight: 'lighter',
      marginTop: '6px',
      marginBottom: '12px',
      textTransform: 'uppercase',
      color: '#666',
      letterSpacing: '0.2em'
    },
    h2: {
      fontFamily: 'Lucida Grande, Tahoma',
      fontSize: '18px',
      fontWeight: 'lighter',
      marginTop: '6px',
      marginBottom: '9px',
      textTransform: 'uppercase',
      color: '#666',
      letterSpacing: '0.2em'
    },
    h3: {
      fontFamily: 'Lucida Grande, Tahoma',
      fontSize: '14px',
      fontWeight: 'lighter',
      marginTop: '3px',
      marginBottom: '3px',
      textTransform: 'uppercase',
      color: '#666',
      letterSpacing: '0.2em'
    },
    h4: {
      fontFamily: 'Lucida Grande, Tahoma',
      fontSize: '12px',
      fontWeight: 'lighter',
      marginTop: '3px',
      marginBottom: '3px',
      color: '#666',
      letterSpacing: '0.2em'
    },
    p: {
      fontFamily: 'Lucida Grande, Tahoma',
      fontSize: '14px',
      fontWeight: 'lighter',
      marginBottom: '12px',
      color: '#222',
      letterSpacing: '0.5 em'
    },
    ul: {
      margin: '0px 0px 22px 30px'
    },
    li: {
      margin: '0px 0px 4px 0px'
    },
    textarea: {
      width: '100%',
      height: '100px',
      borderColor: '#f4f4f4',
      fontFamily: 'Lucida Grande, Tahoma',
      fontSize: '14px'
    },
    '.snippet': {
      margin: 0,
      position: 'relative',
      width: '100%',
      height: '100px',
      border: '1px solid #orange'
    }
  });
};
}}).call(this);})(RR('/_styles.ojc'),P,G,'/','_styles.ojc');});
F['/_snippet.ojc'] = (function(module,exports){(function(require,process,global,__dirname,__filename){(function(){with(require('oj').sandbox){
module.exports = function(default_code) {
  var id;
  id = oj.id();
  return div(function() {
    ready(function() {
      var editor;
      editor = ace.edit(id);
      editor.setTheme("ace/theme/solarized_light");
      editor.getSession().setMode("ace/mode/coffee");
      editor.getSession().setUseSoftTabs(true);
      editor.getSession().setUseWorker(false);
      editor.setDisplayIndentGuides(false);
      editor.getSession().setTabSize(2);
      editor.renderer.setShowGutter(false);
      editor.setHighlightActiveLine(false);
      editor.setReadOnly(true);
      editor.setFontSize(14);
      return editor.renderer.setShowPrintMargin(false);
    });
    return div({
      c: 'snippet',
      id: id
    }, default_code);
  });
};
}}).call(this);})(RR('/_snippet.ojc'),P,G,'/','_snippet.ojc');});
F['/_editor.ojc'] = (function(module,exports){(function(require,process,global,__dirname,__filename){(function(){with(require('oj').sandbox){var chooseExample, clickToggleNext, editor_cs_id, editor_css_id, editor_html_id, editor_js_id, error, examples, getEditor, isCS, recompile, setEditor, setupEditor, success, switchLanguageTabs;

examples = require('./_examples');

editor_cs_id = oj.id();

editor_js_id = oj.id();

editor_html_id = oj.id();

editor_css_id = oj.id();

module.exports = function(default_code) {
  return div({
    c: 'editor'
  }, function() {
    ready(function() {
      setupEditor(editor_cs_id, 'ojc', recompile);
      setupEditor(editor_js_id, 'oj', recompile);
      return recompile();
    });
    css({
      '.editor-source': {
        position: 'relative',
        width: '100%',
        height: '30%',
        border: '2px solid #fbcb7c',
        padding: '10px',
        display: 'block',
        backgroundColor: '#fefaf3',
        boxShadow: '2px 2px 4px RGBA(0,0,0,0.15)'
      },
      '.editor-source-cs': {
        display: 'block',
        width: '100%',
        height: '100%'
      },
      '.editor-source-cs.hidden': {
        display: 'none'
      },
      '.editor-source-js': {
        display: 'block',
        width: '100%',
        height: '100%'
      },
      '.editor-source-js.hidden': {
        display: 'none'
      },
      '.editor-source-css': {
        display: 'block',
        width: '100%',
        height: '100%'
      },
      '.editor-source-html': {
        display: 'block',
        width: '100%',
        height: '100%'
      },
      '.editor-frame': {
        display: 'block',
        position: 'relative',
        width: '100%',
        height: '65%'
      },
      '.editor-iframe': {
        display: 'block',
        width: '100%',
        height: '100%'
      },
      '.editor-console': {
        position: 'absolute',
        top: 0,
        left: 0,
        color: 'darkorange',
        backgroundColor: 'RGBA(255,255,255,0.9)',
        textAlign: 'center',
        fontSize: '18px',
        padding: '14px 4px',
        margin: '0px 0px 10px 0px',
        width: '100%',
        height: '100%'
      },
      '.editor-resizer': {
        width: '100%',
        height: '10px',
        backgroundColor: '#FFBA4D',
        zIndex: 10
      },
      '.editor-bar': {
        position: 'absolute',
        top: '0px',
        right: '0px',
        margin: '8px 8px 0 0',
        height: '21px',
        zIndex: 5
      },
      '.editor-example-chooser': {
        position: 'relative',
        float: 'right',
        height: '100%',
        zIndex: 10,
        fontSize: '20px',
        marginLeft: '8px'
      },
      '.editor-language-tab': {
        display: 'inline-block',
        width: '30px',
        height: '100%',
        float: 'right',
        marginLeft: '0px',
        zIndex: 10,
        backgroundColor: 'white',
        border: '1px solid gray',
        borderRadius: '3px'
      },
      '.editor-language-tab.selected': {
        backgroundColor: '#FECD78'
      }
    });
    div({
      c: 'editor-bar'
    }, function() {
      select({
        c: 'editor-example-chooser',
        change: (function(e) {
          return chooseExample(e);
        })
      }, function() {
        var ex, ix, _i, _len, _results;
        _results = [];
        for (ix = _i = 0, _len = examples.length; _i < _len; ix = ++_i) {
          ex = examples[ix];
          _results.push(option({
            value: ix
          }, "" + ex.name));
        }
        return _results;
      });
      button('JS', {
        c: 'editor-language-tab js',
        click: function(e) {
          switchLanguageTabs();
          return recompile();
        }
      });
      return button('CS', {
        c: 'selected editor-language-tab cs',
        click: function(e) {
          switchLanguageTabs();
          return recompile();
        }
      });
    });
    div({
      c: 'editor-source'
    }, function() {
      div({
        c: 'editor-source-cs',
        id: editor_cs_id
      }, default_code);
      return div({
        c: 'editor-source-js hidden',
        id: editor_js_id
      }, default_code);
    });
    return div({
      c: 'editor-frame'
    }, function() {
      div({
        c: 'editor-console'
      });
      return iframe({
        c: 'editor-iframe'
      });
    });
  });
};

isCS = function() {
  return !$(".editor-source-cs").is(':hidden');
};

chooseExample = function() {
  var $editorChooser, ix;
  $editorChooser = $('.editor-example-chooser');
  ix = $editorChooser.val();
  if (isCS()) {
    setEditor(editor_cs_id, examples[ix].cs);
  } else {
    setEditor(editor_js_id, examples[ix].js);
  }
};

switchLanguageTabs = function() {
  $(".editor-language-tab.cs").toggleClass('selected');
  $(".editor-language-tab.js").toggleClass('selected');
  $(".editor-source-cs").toggleClass('hidden');
  $(".editor-source-js").toggleClass('hidden');
  chooseExample();
  return recompile();
};

recompile = function() {
  var $editorCSS, $editorFrame, $editorHTML, $editorJS, $editorSource, code, ojml, results, wrapjs;
  $editorFrame = $('.editor-iframe');
  $editorSource = $('.editor-source');
  $editorHTML = $('.editor-html');
  $editorCSS = $('.editor-css');
  $editorJS = $('.editor-js');
  if (isCS()) {
    code = getEditor(editor_cs_id);
    try {
      code = CoffeeScript.compile(code, {
        bare: true
      });
    } catch (eCoffee) {
      error('<b>coffee-script error:</b> ' + eCoffee.message);
      return;
    }
  } else {
    code = getEditor(editor_js_id);
  }
  wrapjs = "with(oj){" + code + "}";
  try {
    ojml = eval(wrapjs);
  } catch (eRuntime) {
    error('<b>runtime error:</b> ' + eRuntime.message);
    return;
  }
  try {
    results = oj.compile({
      debug: true
    }, ojml);
    if (!(results.tags.html != null) && !(results.tags.head != null) && !(results.tags.body != null)) {
      wrapjs = "with(oj){\n  html(function(){\n    head();\n    body(function(){\n      " + code + "\n    });\n  })\n}";
      ojml = eval(wrapjs);
      results = oj.compile({
        debug: true
      }, ojml);
    }
    if (!(results.tags.html != null)) {
      error('<b>validation error</b>: <html> tag is missing');
      return;
    }
    if (!(results.tags.head != null)) {
      error('<b>validation error</b>: <head> tag is missing');
      return;
    }
    if (!(results.tags.body != null)) {
      error('<b>validation error</b>: <body> tag is missing');
      return;
    }
  } catch (eCompile) {
    error('<b>oj error:</b> ' + eCompile.message);
    return;
  }
  $editorHTML.val(results.html);
  $editorCSS.val(results.css);
  $editorFrame.contents().find('html').replaceWith($(results.dom));
  $editorFrame.contents().find('head').append("<style>" + results.css + "</style>");
  return success();
};

error = function(message) {
  var $editorConsole;
  $editorConsole = $('.editor-console');
  $editorConsole.html(message);
  $editorConsole.show();
};

success = function() {
  var $editorConsole;
  $editorConsole = $('.editor-console');
  $editorConsole.hide();
};

clickToggleNext = function() {
  return {
    click: function(e) {
      return $(e.target).next().toggle();
    }
  };
};

setupEditor = function(editor_id, language, onChange) {
  var editor;
  editor = ace.edit(editor_id);
  editor.setTheme("ace/theme/orange");
  editor.getSession().setMode("ace/mode/" + language);
  editor.getSession().setUseSoftTabs(true);
  editor.getSession().setUseWorker(false);
  editor.setDisplayIndentGuides(true);
  editor.getSession().setTabSize(2);
  editor.renderer.setShowGutter(false);
  editor.setHighlightActiveLine(false);
  editor.renderer.setShowPrintMargin(false);
  editor.setReadOnly(false);
  editor.setFontSize(16);
  editor.getSession().doc.on('change', onChange);
};

setEditor = function(editor_id, code) {
  var editor;
  editor = ace.edit(editor_id);
  editor.getSession().setValue(code);
};

getEditor = function(editor_id) {
  var editor;
  editor = ace.edit(editor_id);
  return editor.getSession().getValue();
};
}}).call(this);})(RR('/_editor.ojc'),P,G,'/','_editor.ojc');});
F['/_examples.ojc'] = (function(module,exports){(function(require,process,global,__dirname,__filename){(function(){with(require('oj').sandbox){
module.exports = [
  {
    name: '',
    cs: "",
    js: ""
  }, {
    name: 'Headers and Paragraphs',
    cs: "h1 'Headers and Paragraphs'\np 'Paragraphs and headers can be made by simply using tag functions.'\np 'Live change this text to see how it works!'",
    js: "h1('Headers and Paragraphs');\np('Paragraphs and headers can be made by simply using tag functions.');\np(' Live change this text to see how it works!');"
  }, {
    name: 'Markdown',
    cs: "# Use the markdown plugin\nuse require 'oj-markdown'\n\n# The plugin enables this function:\nmarkdown \"\"\"\n  # Markdown\n\n  It is _so easy_ to use markdown with oj:\n\n  1. Just `use` the plugin\n  2. Then call the `markdown` function!\n\"\"\"",
    js: "// Use the markdown plugin\nuse(require('oj-markdown'));\n\n// The plugin enables this function:\nmarkdown(\n  \"# Markdown                                  \\n\" +\n  \"                                            \\n\" +\n  \"It is _so easy_ to use markdown with oj:    \\n\" +\n  \"                                            \\n\" +\n  \"1. Just `use` the plugin                    \\n\" +\n  \"2. Then call the `markdown` function!       \\n\"\n);"
  }, {
    name: 'Defining ID and Class',
    cs: "# Define id with 'id'\ndiv id:'my-id', 'This div has id \"my-id\".'\n\n# Define class with 'c' or 'class'\ndiv c:'my-class', 'This div has class \"my-class\"',\n\ncss\n  '#my-id': color: 'purple'\n  '.my-class': color: 'blue'",
    js: "// Define id with 'id'\ndiv({id:'my-id'}, 'This div has id \"my-id\".');\n\n// Define class with 'c' or 'class'\ndiv({c:'my-class'}, 'This div has class \"my-class\"');\n\ncss({\n  '#my-id': {color: 'purple'},\n  '.my-class': {color: 'blue'}\n});"
  }, {
    name: 'Tags with Inline Styles',
    cs: "div 'This div has an inline styles',\n\n  # Inline styles are defined with and object\n  style:\n\n    border:'1px solid lightgrey'\n    padding: '15px'\n\n    # camalCase is automatically seperated-by-dashes\n    borderRadius: '5px'",
    js: "div('This div has an inline styles', {\n\n  // Inline styles are defined with and object\n  style: {\n\n    border:'1px solid lightgrey',\n    padding: '15px',\n\n    // camalCase is automatically seperated-by-dashes\n    borderRadius: '5px'\n  }\n});"
  }, {
    name: 'Tags with Click Events',
    cs: "div c:'button', 'Click Me',\n  # Click event binds automatically through jquery!\n  click: ->\n    alert 'Click works!'\n\n# Make it look like a button\ncss\n  '.button':\n    border:'1px solid black'\n    width: 100\n    borderRadius: 5\n    padding: 5\n    boxShadow: '3px 3px 5px #999'\n    cursor:'pointer'",
    js: "div({c:'button'}, 'Click Me', {\n  // Click event binds automatically through jquery!\n  click: function(){\n    alert('Click works!');\n  }\n});\n\n// Make it look like a button\ncss ({\n  '.button': {\n    border:'1px solid black',\n    width: 100,\n    borderRadius: 5,\n    padding: 5,\n    boxShadow: '3px 3px 5px #999',\n    cursor:'pointer'\n  }\n});"
  }, {
    name: 'Tags with Several Attributes',
    cs: "div c:'my-class', id: 'my-id',\n  'This div has three attributes (click me to see)',\n\n  # Attributes can be defined before or after the content\n  'data-id': '1234'\n\n  click: (e) ->\n    $target = $(e.target)\n    alert \"\"\"\n      data-id: #\{$target.attr('data-id')\}\n      class:   #\{$target.attr('class')\}\n      id:      #\{$target.attr('id')\}\n    \"\"\"",
    js: "div({c:'my-class', id: 'my-id'},\n  'This div has three attributes (click me to see)', {\n  // Attributes can be defined before or after the content\n  'data-id': '1234',\n\n  click: function(e) {\n    $target = $(e.target)\n    alert( \"data-id: \" + $target.attr('data-id') + \"\\n\" +\n           \"class: \"   + $target.attr('class')   + \"\\n\" +\n           \"id: \"      + $target.attr('id') );\n  }\n});"
  }, {
    name: 'Create a Checkbox',
    cs: "CheckBox value:true, change: (control) ->\n  alert \"The checkbox changed to: \#{control.value}\"",
    js: "CheckBox({value:true, change: function(control){\n  alert(\"The checkbox changed to: \" + control.value);\n}});"
  }, {
    name: 'Create a TextBox',
    cs: "TextBox value:'The text goes here', change: (control) ->\n  alert \"The textbox changed to: \#{control.value}\"",
    js: "TextBox({value:'The text goes here', change: function(control){\n  alert(\"The textbox changed to: \" + control.value);\n}});"
  }, {
    name: 'Create a TextArea',
    cs: "TextArea value:'The text goes here', change: (control) ->\n  alert \"The textarea changed to: \#{control.value}\"",
    js: "TextArea({value:'The text goes here', change: function(control){\n  alert(\"The textarea changed to: \" + control.value);\n}});"
  }, {
    name: 'Creating a Template',
    cs: "# Define a simple template with a title and a content function\n# Create a template that takes data as input and outputs the page\nmyTemplate = (data) ->\n  html ->\n    head ->\n      # Template the title\n      title data.title\n    body ->\n      h1 data.header\n      # Template the content\n      data.content()\n\n# Run the template\nmyTemplate title:'My Title', header:'Creating a Template', content:->\n  p 'Templates are just functions that call html, head and body. Presto, they just work!'",
    js: "// Define a simple template with a title and a content function\n// Create a template that takes data as input and outputs the page\nmyTemplate = function(data){ return [\n  html,\n    [head,\n      [title, data.title]\n    ],\n    [body,\n      [h1, data.header],\n      // Template the content\n      data.content\n    ]\n  ];\n}\n// Run the template\nmyTemplate({ title:'My Title', header:'Creating a Template', content:function(){\n  p('Templates are just functions that call html, head and body. Presto, they just work!');\n}});"
  }, {
    name: 'Create a Partial',
    cs: "# Define a partial that creates a twitter link for a user\n_userTwitterLink = (user) ->\n  a \"Follow \#{user.name} on Twitter\",\n    href: \"http://twitter.com/\#{user.twitter}\"\n\n# Define some users\nusers = [\n  {name:'Evan', twitter:'evanmoran'}\n  {name:'James', twitter:'iamthelawton'}\n  {name:'Laura', twitter:'savinola'}\n]\n\np 'Partials are just functions. This function turns a user into a Twitter link:'\n\nfor user in users\n  # Use the partial!\n  p _userTwitterLink user",
    js: "// Define a partial that creates a twitter link for a user\n_userTwitterLink = function(user){\n  a(\"Follow \" + user.name + \" on Twitter\", {\n    href: \"http://twitter.com/\" + user.twitter});\n};\n// Define some users\nusers = [\n  {name:'Evan', twitter:'evanmoran'},\n  {name:'James', twitter:'iamthelawton'},\n  {name:'Laura', twitter:'savinola'}\n];\n\np('Partials are just functions. This function turns a user into a Twitter link:');\n\nvar user;\nfor(var ix = 0; ix < users.length; ix++){\n  user = users[ix];\n  // Use the partial!\n  p(_userTwitterLink(user));\n}"
  }, {
    name: 'Create a Table',
    cs: "table ->\n  tbody ->\n    tr ->\n      td 'A1'\n      td 'A2'\n      td 'A3'\n      td 'A4'\n    tr ->\n      # Loops work as you would hope!\n      for cell in ['B1','B2','B3','B4']\n        td cell\n\n  css\n    td:\n      border: '1px solid darkorange'\n      padding: 10",
    js: "table(\n  [tbody,\n    [tr,\n      [td, 'A1'],\n      [td, 'A2'],\n      [td, 'A3'],\n      [td, 'A4']\n    ],\n    function(){\n      var cells = ['B1','B2','B3','B4'];\n      for(var ix = 0; ix < cells.length; ix++) {\n        td(cells[ix]);\n      }\n    }\n  ]\n);\ncss({\n  td:{\n    border: '1px solid darkorange',\n    padding: 10\n  }\n});"
  }, {
    name: 'Create a Table Partial',
    cs: "# Create a partial that creates a table from its\n# header (a list of strings) and its rows (a list of lists)\nmakeTable = (header, rows) ->\n\n  table ->\n    # Define headers\n    thead ->\n      tr ->\n        for h in header\n          th h\n\n    # Define rows\n    tbody ->\n      for row in rows\n        tr ->\n          for column in row\n            td column\n\n# Make it by calling the function!\ndiv ->\n  makeTable ['H1', 'H2', 'H3', 'H4'], [\n    ['A1','A2','A3','A4']\n    ['B1','B2','B3','B4']\n    ['C1','C2','C3','C4']\n  ]\n  css\n    th:\n      color: 'darkorange'\n    td:\n      backgroundColor: 'orange'\n      padding:'50px'"
  }
];
}}).call(this);})(RR('/_examples.ojc'),P,G,'/','_examples.ojc');});
F['oj'] = (function(module,exports){(function(process,global,__dirname,__filename){// Generated by CoffeeScript 1.3.3
(function() {
  var ArrayP, FuncP, ObjP, coffee, exports, fs, jqueryEvents, key, oj, pass, pathNormalizeArray, pathSplit, pathSplitRe, root, slice, stripBOM, t, unshift, wrapCSMessage, wrapJS, wrapJSMessage, _, _attributeCMeansClass, _attributeClassAllowsArrays, _attributeStyleAllowsObject, _attributesFilterOutEvents, _attributesFromObject, _chars, _compileAny, _compileDeeper, _compileTag, _cssFromObject, _defaultClear, _fn, _i, _j, _len, _len1, _randomInteger, _readyOrLoad, _readyQueue, _ref, _ref1, _styleFromObject, _styleKeyFromFancy, _tagAttributes,
    __slice = [].slice;

  oj = module.exports = function(ojml) {
    return oj.tag('oj', ojml);
  };

  oj.oj = oj;

  oj.begin = function(page) {
    return _readyOrLoad(function() {
      var body, bodyOnly, d, dom, _i, _len;
      bodyOnly = {
        html: 1,
        doctype: 1,
        head: 1,
        link: 1,
        script: 1
      };
      dom = oj.compile({
        dom: 1,
        html: 0,
        css: 0,
        ignore: bodyOnly
      }, require(page)).dom;
      if (!(dom != null)) {
        console.error('oj: dom failed to compile');
        return;
      }
      body = document.getElementsByTagName('body');
      if (body.length === 0) {
        console.error('oj: <body> was not found');
        return;
      }
      body = body[0];
      body.innerHTML = '';
      if (!oj.isArray(dom)) {
        dom = [dom];
      }
      for (_i = 0, _len = dom.length; _i < _len; _i++) {
        d = dom[_i];
        body.appendChild(d);
      }
      return oj.ready();
    });
  };

  _readyOrLoad = function(fn) {
    var prevOnLoad;
    if (typeof $ !== "undefined" && $ !== null) {
      $(fn);
    } else {
      if (document.readyState !== "complete") {
        prevOnLoad = window.onload;
        window.onload = function() {
          if (typeof prevOnLoad === "function") {
            prevOnLoad();
          }
          return fn();
        };
      } else {
        fn();
      }
    }
  };

  _readyQueue = {
    queue: [],
    loaded: false
  };

  oj.ready = function(fn) {
    var f;
    if (oj.isUndefined(fn)) {
      _readyQueue.loaded = true;
      while ((f = _readyQueue.queue.shift())) {
        f();
      }
    } else if (_readyQueue.loaded) {
      f();
    } else {
      _readyQueue.queue.push(fn);
    }
  };

  oj.id = function(len, chars) {
    return 'oj' + oj.guid(len, chars);
  };

  _randomInteger = function(min, max) {
    var diff, rnd;
    if (min === null || max === null || min > max) {
      return null;
    }
    diff = max - min;
    rnd = Math.floor(Math.random() * (diff + 1));
    return rnd + min;
  };

  _chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split('');

  oj.guid = function(len, chars) {
    var base, charNext, charsPerRand, i, output, rand, randMax, randMin, _i;
    if (len == null) {
      len = 8;
    }
    if (chars == null) {
      chars = _chars;
    }
    base = chars.length;
    charsPerRand = Math.floor(Math.log(Math.pow(2, 31) - 1) / Math.log(base));
    randMin = 0;
    randMax = Math.pow(base, charsPerRand) - 1;
    output = "";
    for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
      if (i % charsPerRand === 0) {
        rand = _randomInteger(randMin, randMax);
      }
      charNext = chars[rand % base];
      output += charNext;
      rand = Math.floor(rand / base);
    }
    return output;
  };

  if (require.extensions) {
    coffee = require('coffee-script');
    fs = require(new String('fs'));
    stripBOM = function(c) {
      if (c.charCodeAt(0) === 0xFEFF) {
        return c.slice(1);
      } else {
        return c;
      }
    };
    wrapJS = function(code) {
      return "(function(){with(require('oj').sandbox){" + code + "}}).call(this);";
    };
    wrapCSMessage = function(message, filepath) {
      var _ref, _ref1;
      return "" + ((_ref = oj.codes) != null ? _ref.red : void 0) + "coffee-script error in " + filepath + ": " + message + ((_ref1 = oj.codes) != null ? _ref1.reset : void 0);
    };
    wrapJSMessage = function(message, filepath) {
      var _ref, _ref1;
      return "" + ((_ref = oj.codes) != null ? _ref.red : void 0) + "javascript error in " + filepath + ": " + message + ((_ref1 = oj.codes) != null ? _ref1.reset : void 0);
    };
    require.extensions['.oj'] = function(module, filepath) {
      var code;
      code = stripBOM(fs.readFileSync(filepath, 'utf8'));
      try {
        code = wrapJS(code);
        return module._compile(code, filepath);
      } catch (eJS) {
        eJS.message = wrapJSMessage(eJS.message, filepath);
        throw eJS;
      }
    };
    require.extensions['.ojc'] = function(module, filepath) {
      var code;
      code = stripBOM(fs.readFileSync(filepath, 'utf8'));
      try {
        code = coffee.compile(code, {
          bare: true
        });
      } catch (eCoffee) {
        eCoffee.message = wrapCSMessage(eCoffee.message, filepath);
        throw eCoffee;
      }
      try {
        code = wrapJS(code);
        return module._compile(code, filepath);
      } catch (eJS) {
        eJS.message = wrapJSMessage(eJS.message, filepath);
        throw eJS;
      }
    };
  }

  root = this;

  oj.version = '0.0.8';

  oj.isClient = true;

  if (typeof module !== 'undefined') {
    exports = module.exports = oj;
  } else {
    root['oj'] = oj;
  }

  oj.isUndefined = function(obj) {
    return obj === void 0;
  };

  oj.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  oj.isNumber = function(obj) {
    return !!(obj === 0 || (obj && obj.toExponential && obj.toFixed));
  };

  oj.isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  oj.isDate = function(obj) {
    return !!(obj && obj.getTimezoneOffset && obj.setUTCFullYear);
  };

  oj.isFunction = function(obj) {
    return typeof obj === 'function';
  };

  oj.isArray = Array.isArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  oj.isRegEx = function(obj) {
    return toString.call(obj) === '[object RegExp]';
  };

  oj.isDOM = function(obj) {
    return !!(obj && (obj.nodeType != null));
  };

  oj.isDOMElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  oj.isDOMAttribute = function(obj) {
    return !!(obj && obj.nodeType === 2);
  };

  oj.isDOMText = function(obj) {
    return !!(obj && obj.nodeType === 3);
  };

  oj.isjQuery = function(obj) {
    return !!(obj && obj.jquery);
  };

  oj.isBackbone = function(obj) {
    return !!(obj && obj.on && obj.off && obj.trigger);
  };

  oj.isOJ = function(obj) {
    return !!(obj != null ? obj.isOJ : void 0);
  };

  oj.isArguments = function(obj) {
    return toString.call(obj) === '[object Arguments]';
  };

  oj.typeOf = function(any) {
    var t;
    if (any === null) {
      return 'null';
    }
    t = typeof any;
    if (t === 'object') {
      if (oj.isArray(any)) {
        t = 'array';
      } else if (oj.isOJ(any)) {
        t = any.type;
      } else if (oj.isRegEx(any)) {
        t = 'regexp';
      } else if (oj.isDate(any)) {
        t = 'date';
      } else if (oj.isDOMElement(any)) {
        t = 'element';
      } else if (oj.isDOMText(any)) {
        t = 'text';
      } else if (oj.isDOMAttribute(any)) {
        t = 'attribute';
      } else if (oj.isBackbone(any)) {
        t = 'backbone';
      } else if (oj.isjQuery(any)) {
        t = 'jquery';
      } else {
        t = 'object';
      }
    }
    return t;
  };

  oj.isObject = function(obj) {
    return (oj.typeOf(obj)) === 'object';
  };

  ArrayP = Array.prototype;

  FuncP = Function.prototype;

  ObjP = Object.prototype;

  slice = ArrayP.slice;

  unshift = ArrayP.unshift;

  oj.__ = _ = {};

  _.isCapitalLetter = function(c) {
    return !!(c.match(/[A-Z]/));
  };

  _.identity = function(v) {
    return v;
  };

  _.property = function(obj, options) {
    if (options == null) {
      options = {};
    }
    return Object.defineProperty(obj, options);
  };

  _.has = function(obj, key) {
    return ObjP.hasOwnProperty.call(obj, key);
  };

  _.keys = Object.keys || function(obj) {
    var key, keys;
    if (obj !== Object(obj)) {
      throw 'Invalid object';
    }
    keys = [];
    for (key in obj) {
      if (_has(obj, key)) {
        keys[keys.length] = key;
      }
    }
    return keys;
  };

  _.values = function(obj) {
    var out;
    if (obj !== Object(obj)) {
      throw 'Invalid object';
    }
    out = [];
    _.each(obj, function(v) {
      return out.push(v);
    });
    return out;
  };

  _.flatten = function(array, shallow) {
    return _.reduce(array, (function(memo, value) {
      if (oj.isArray(value)) {
        return memo.concat(shallow ? value : _.flatten(value));
      }
      memo[memo.length] = value;
      return memo;
    }), []);
  };

  _.reduce = function(obj, iterator, memo, context) {
    var ctor, initial;
    if (obj == null) {
      obj = [];
    }
    initial = arguments.length > 2;
    if (ArrayP.reduce && obj.reduce === ArrayP.reduce) {
      if (context) {
        iterator = _.bind(iterator, context);
      }
      if (initial) {
        return obj.reduce(iterator, memo);
      } else {
        return obj.reduce(iterator);
      }
    }
    _.each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        return initial = true;
      } else {
        return memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    memo;

    ctor = function() {};
    return _.bind = function(func, context) {
      var args, bound;
      if (func.bind === FuncP.bind && FuncP.bind) {
        return FuncP.bind.apply(func, slice.call(arguments, 1));
      }
      if (!oj.isFunction(func)) {
        throw new TypeError;
      }
      args = slice.call(arguments, 2);
      return bound = function() {
        var result, self;
        if (!(this instanceof bound)) {
          return func.apply(context, args.concat(slice.call(arguments)));
        }
        ctor.prototype = func.prototype;
        self = new ctor;
        result = func.apply(self, args.concat(slice.call(arguments)));
        if (Object(result) === result) {
          return result;
        }
        return self;
      };
    };
  };

  _.sortedIndex = function(array, obj, iterator) {
    var high, low, mid;
    if (iterator == null) {
      iterator = _.identity;
    }
    low = 0;
    high = array.length;
    while (low < high) {
      mid = (low + high) >> 1;
      if (iterator(array[mid]) < iterator(obj)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return low;
  };

  _.indexOf = function(array, item, isSorted) {
    var i, v, _i, _len;
    if (array == null) {
      return -1;
    }
    if (isSorted) {
      i = _.sortedIndex(array, item);
      if (array[i] === item) {
        return i;
      } else {
        return -1;
      }
    }
    if (ArrayP.indexOf && array.indexOf === ArrayP.indexOf) {
      return array.indexOf(item);
    }
    for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
      v = array[i];
      if (v === item) {
        return i;
      }
    }
    return -1;
  };

  _.toArray = function(obj) {
    if (!obj) {
      return [];
    }
    if (oj.isArray(obj)) {
      return slice.call(obj);
    }
    if (oj.isArguments(obj)) {
      return slice.call(obj);
    }
    if (obj.toArray && oj.isFunction(obj.toArray)) {
      return obj.toArray();
    }
    return _.values(obj);
  };

  _.isEmpty = function(obj) {
    var k;
    if (oj.isArray(obj)) {
      return obj.length === 0;
    }
    for (k in obj) {
      if (_.has(obj, k)) {
        return false;
      }
    }
    return true;
  };

  _.clone = function(obj) {
    if (!oj.isObject(obj)) {
      return obj;
    }
    if (oj.isArray(obj)) {
      return obj.slice();
    } else {
      return _.extend({}, obj);
    }
  };

  _.breaker = {};

  _.each = function(col, iterator, context) {
    var i, k, v, _i, _len;
    if (col === null) {
      return;
    }
    if (ArrayP.forEach && col.forEach === ArrayP.forEach) {
      return col.forEach(iterator, context);
    } else if (oj.isArray(col)) {
      for (i = _i = 0, _len = col.length; _i < _len; i = ++_i) {
        v = col[i];
        if (iterator.call(context, v, i, col) === _.breaker) {
          return _.breaker;
        }
      }
    } else {
      for (k in col) {
        v = col[k];
        if (_.has(col, k)) {
          if (iterator.call(context, v, k, col) === _.breaker) {
            return _.breaker;
          }
        }
      }
    }
  };

  _.map = function(obj, iterator, options) {
    var context, evaluate, iterator_, k, out, r, recurse, v;
    if (options == null) {
      options = {};
    }
    context = options.context;
    recurse = options.recurse;
    evaluate = options.evaluate;
    iterator_ = iterator;
    if (recurse) {
      (function(options) {
        return iterator_ = function(v, k, o) {
          var options_;
          options_ = _.extend(_.clone(options), {
            key: k,
            object: v
          });
          return _.map(v, iterator, options_);
        };
      })(options);
    }
    if (oj.isFunction(obj)) {
      if (!evaluate) {
        return obj;
      }
      while (evaluate && oj.isFunction(obj)) {
        obj = obj();
      }
    }
    out = obj;
    if (oj.isArray(obj)) {
      out = [];
      if (!obj) {
        return out;
      }
      if (ArrayP.map && obj.map === ArrayP.map) {
        return obj.map(iterator_, context);
      }
      _.each(obj, (function(v, ix, list) {
        return out[out.length] = iterator_.call(context, v, ix, list);
      }));
      if (obj.length === +obj.length) {
        out.length = obj.length;
      }
    } else if (oj.isObject(obj)) {
      out = {};
      if (!obj) {
        return out;
      }
      for (k in obj) {
        v = obj[k];
        if ((r = iterator_.call(context, v, k, obj)) !== void 0) {
          out[k] = r;
        }
      }
    } else {
      return iterator.call(context, obj, options.key, options.object);
    }
    return out;
  };

  _.extend = function(obj) {
    _.each(slice.call(arguments, 1), (function(source) {
      var key, value, _results;
      _results = [];
      for (key in source) {
        value = source[key];
        _results.push(obj[key] = value);
      }
      return _results;
    }));
    return obj;
  };

  _.defaults = function(obj) {
    _.each(slice.call(arguments, 1), (function(source) {
      var prop, _results;
      _results = [];
      for (prop in source) {
        if (!(obj[prop] != null)) {
          _results.push(obj[prop] = source[prop]);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }));
    return obj;
  };

  _.uniqueSort = function(array, isSorted) {
    var item, ix, out, _i, _len;
    if (isSorted == null) {
      isSorted = false;
    }
    if (!isSorted) {
      array.sort();
    }
    out = [];
    for (ix = _i = 0, _len = array.length; _i < _len; ix = ++_i) {
      item = array[ix];
      if (ix > 0 && array[ix - 1] === array[ix]) {
        continue;
      }
      out.push(item);
    }
    return out;
  };

  _.uniqueSortedUnion = function(array, array2) {
    return _.uniqueSort(array.concat(array2));
  };

  pathNormalizeArray = function(parts, allowAboveRoot) {
    var i, last, up;
    up = 0;
    i = parts.length - 1;
    while (i >= 0) {
      last = parts[i];
      if (last === '.') {
        parts.splice(i, 1);
      } else if (last === '..') {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
      i--;
    }
    if (allowAboveRoot) {
      while (up--) {
        parts.unshift('..');
      }
    }
    return parts;
  };

  pathSplitRe = /^(\/?)([\s\S]+\/(?!$)|\/)?((?:\.{1,2}$|[\s\S]+?)?(\.[^.\/]*)?)$/;

  pathSplit = function(filename) {
    var result;
    result = pathSplitRe.exec(filename);
    return [result[1] || '', result[2] || '', result[3] || '', result[4] || ''];
  };

  _.pathResolve = function() {
    var i, path, resolvedAbsolute, resolvedPath;
    resolvedPath = '';
    resolvedAbsolute = false;
    i = arguments.length - 1;
    while (i >= -1 && !resolvedAbsolute) {
      path = i >= 0 ? arguments[i] : process.cwd();
      if ((typeof path !== 'string') || !path) {
        continue;
      }
      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
      i--;
    }
    resolvedPath = pathNormalizeArray(resolvedPath.split('/').filter(function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');
    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  };

  _.pathNormalize = function(path) {
    var isAbsolute, trailingSlash;
    isAbsolute = path.charAt(0) === '/';
    trailingSlash = path.substr(-1) === '/';
    path = pathNormalizeArray(path.split('/').filter(function(p) {
      return !!p;
    }), !isAbsolute).join('/');
    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }
    return (isAbsolute ? '/' : '') + path;
  };

  _.pathJoin = function() {
    var paths;
    paths = Array.prototype.slice.call(arguments, 0);
    return _.pathNormalize(paths.filter(function(p, index) {
      return p && typeof p === 'string';
    }).join('/'));
  };

  _.pathDirname = function(path) {
    var dir, result;
    result = pathSplit(path);
    root = result[0];
    dir = result[1];
    if (!root && !dir) {
      return '.';
    }
    if (dir) {
      dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
  };

  oj.addMethods = function(obj, mapNameToMethod) {
    var method, methodName;
    for (methodName in mapNameToMethod) {
      method = mapNameToMethod[methodName];
      oj.addMethod(obj, methodName, method);
    }
  };

  oj.addMethod = function(obj, methodName, method) {
    if (!oj.isString(methodName)) {
      throw 'oj.addMethod: string expected for second argument';
    }
    if (!oj.isFunction(method)) {
      throw 'oj.addMethod: function expected for thrid argument';
    }
    Object.defineProperty(obj, methodName, {
      value: method,
      enumerable: false,
      writable: false,
      configurable: true
    });
  };

  oj.removeMethod = function(obj, methodName) {
    if (!oj.isString(methodName)) {
      throw 'oj.removeMethod: string expected for second argument';
    }
    delete obj[methodName];
  };

  oj.addProperties = function(obj, mapNameToInfo) {
    var propInfo, propName;
    for (propName in mapNameToInfo) {
      propInfo = mapNameToInfo[propName];
      if (!((propInfo != null ? propInfo.get : void 0) != null) && !((propInfo != null ? propInfo.value : void 0) != null)) {
        propInfo = {
          value: propInfo
        };
      }
      oj.addProperty(obj, propName, propInfo);
    }
  };

  oj.addProperty = function(obj, propName, propInfo) {
    if (!oj.isString(propName)) {
      throw 'oj.addProperty: string expected for second argument';
    }
    if (!(oj.isObject(propInfo))) {
      throw 'oj.addProperty: object expected for third argument';
    }
    if (!((propInfo.get != null) || (propInfo.value != null))) {
      throw 'oj.addProperty: get or value key expected in third argument';
    }
    _.defaults(propInfo, {
      enumerable: true,
      configurable: true
    });
    if (Object.getOwnPropertyDescriptor(obj, propName) != null) {
      oj.removeProperty(obj, propName);
    }
    Object.defineProperty(obj, propName, propInfo);
  };

  oj.removeProperty = function(obj, propName) {
    if (!oj.isString(propName)) {
      throw 'oj.addProperty: string expected for second argument';
    }
    return delete obj[propName];
  };

  oj.isProperty = function(obj, propName) {
    if (!oj.isString(propName)) {
      throw 'oj.isProperty: string expected for second argument';
    }
    return Object.getOwnPropertyDescriptor(obj, propName).get != null;
  };

  oj.copyProperty = function(dest, source, propName) {
    var info;
    info = Object.getOwnPropertyDescriptor(source, propName);
    return Object.defineProperty(dest, propName, info);
  };

  _.argumentsStack = [];

  oj.addProperty(_, 'arguments', {
    get: function() {
      if (_.argumentsStack.length) {
        return _.argumentsStack[_.argumentsStack.length - 1];
      } else {
        return null;
      }
    }
  });

  _.argumentsPush = function(args) {
    if (args == null) {
      args = [];
    }
    _.argumentsStack.push(args);
  };

  _.argumentsPop = function() {
    if (_.argumentsStack.length) {
      return _.argumentsStack.pop();
    }
    return null;
  };

  _.argumentsAppend = function(arg) {
    if (_["arguments"]) {
      _["arguments"].push(arg);
    }
  };

  oj.tag = function() {
    var arg, args, attributes, len, name, ojml, r, _i, _j, _len, _len1;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!oj.isString(name)) {
      throw 'oj.tag error: argument 1 is not a string (expected tag name)';
    }
    ojml = [name];
    attributes = {};
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      if (oj.isObject(arg)) {
        _.extend(attributes, arg);
      }
    }
    attributes = _tagAttributes(name, attributes);
    if (!_.isEmpty(attributes)) {
      ojml.push(attributes);
    }
    _.argumentsPush(ojml);
    for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
      arg = args[_j];
      if (oj.isObject(arg)) {
        continue;
      } else if (oj.isFunction(arg)) {
        len = _["arguments"].length;
        r = arg();
        if (len === _["arguments"].length && (r != null)) {
          _.argumentsAppend(r);
        }
      } else {
        _.argumentsAppend(arg);
      }
    }
    _.argumentsPop();
    _.argumentsAppend(ojml);
    return ojml;
  };

  oj.tag.elements = {
    closed: 'a abbr acronym address applet article aside audio b bdo big blockquote body button canvas caption center cite code colgroup command datalist dd del details dfn dir div dl dt em embed fieldset figcaption figure font footer form frameset h1 h2 h3 h4 h5 h6 head header hgroup html i iframe ins keygen kbd label legend li map mark menu meter nav noframes noscript object ol optgroup option output p pre progress q rp rt ruby s samp script section select small source span strike strong style sub summary sup table tbody td textarea tfoot th thead time title tr tt u ul var video wbr xmp'.split(' '),
    open: 'area base br col command css embed hr img input keygen link meta param source track wbr'.split(' ')
  };

  oj.tag.elements.all = (oj.tag.elements.closed.concat(oj.tag.elements.open)).sort();

  oj.tag.isClosed = function(tag) {
    return (_.indexOf(oj.tag.elements.open, tag, true)) === -1;
  };

  _ref = oj.tag.elements.all;
  _fn = function(t) {
    oj[t] = function() {
      return oj.tag.apply(oj, [t].concat(__slice.call(arguments)));
    };
    return oj[t].type = t;
  };
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    t = _ref[_i];
    _fn(t);
  }

  _defaultClear = function(dest, d, e) {
    var k;
    _.defaults(dest, d);
    for (k in e) {
      delete dest[k];
    }
    return dest;
  };

  _tagAttributes = function(name, attributes) {
    var attr;
    attr = _.clone(attributes);
    switch (name) {
      case 'link':
        _defaultClear(attr, {
          rel: 'stylesheet',
          type: 'text/css',
          href: attr.url || attr.src
        }, {
          url: 0,
          src: 0
        });
        break;
      case 'script':
        _defaultClear(attr, {
          type: 'text/javascript',
          src: attr.url
        }, {
          url: 0
        });
        break;
      case 'a':
        _defaultClear(attr, {
          href: attr.url
        }, {
          url: 0
        });
    }
    return attr;
  };

  oj.page = function(options, content) {
    if (!(content != null)) {
      content = options;
      options = {};
    }
    return oj.html(function() {
      oj.head(function() {
        if (options.title != null) {
          return oj.title(options.title);
        }
      });
      return oj.body(function() {
        return content();
      });
    });
  };

  oj.extend = function(context) {
    var k, o, v;
    o = {};
    for (k in oj) {
      v = oj[k];
      if (k[0] !== '_') {
        o[k] = v;
      }
    }
    delete o.extend;
    return _.extend(context, o);
  };

  oj.compile = function(options, ojml) {
    var css, dom, html, out;
    if (!(ojml != null)) {
      ojml = options;
      options = {};
    }
    options = _.defaults({}, options, {
      html: true,
      dom: true,
      css: true,
      debug: false,
      ignore: {}
    });
    _.extend(options.ignore, {
      oj: 1,
      css: 1
    });
    options.html = options.html ? [] : null;
    options.dom = options.dom && (typeof document !== "undefined" && document !== null) ? document.createElement('OJ') : null;
    options.css = options.css ? {} : null;
    options.indent = '';
    options.types = [];
    options.tags = {};
    _compileAny(ojml, options);
    if (options.css) {
      css = _cssFromObject(options.css, options.debug);
    }
    if (options.html != null) {
      html = options.html.join('');
    }
    if (options.dom != null) {
      dom = options.dom.childNodes;
      if (dom.length != null) {
        dom = _.toArray(dom);
        dom = dom.filter(function(v) {
          return oj.isDOM(v);
        });
      }
      if (dom.length === 0) {
        dom = null;
      } else if (dom.length === 1) {
        dom = dom[0];
      }
    }
    out = {
      html: html,
      dom: dom,
      css: css,
      types: options.types,
      tags: options.tags
    };
    return out;
  };

  _styleKeyFromFancy = function(key) {
    var c, out, _j, _len1;
    out = "";
    for (_j = 0, _len1 = key.length; _j < _len1; _j++) {
      c = key[_j];
      if (_.isCapitalLetter(c)) {
        out += "-" + (c.toLowerCase());
      } else {
        out += c;
      }
    }
    return out;
  };

  _styleFromObject = function(obj, options) {
    var indent, ix, k, kFancy, keys, newline, out, semi, _j, _len1;
    if (options == null) {
      options = {};
    }
    _.defaults(options, {
      inline: true,
      indent: false
    });
    options.semi = !options.inline;
    out = "";
    keys = _.keys(obj).sort();
    indent = options.indent ? '\t' : '';
    newline = options.inline ? '' : '\n';
    for (ix = _j = 0, _len1 = keys.length; _j < _len1; ix = ++_j) {
      kFancy = keys[ix];
      semi = options.semi || ix !== keys.length - 1 ? ";" : '';
      k = _styleKeyFromFancy(kFancy);
      out += "" + indent + k + ":" + obj[kFancy] + semi + newline;
    }
    return out;
  };

  _attributesFromObject = function(obj) {
    var k, out, space, v, _j, _len1, _ref1;
    if (!oj.isObject(obj)) {
      return obj;
    }
    out = '';
    space = '';
    _ref1 = _.keys(obj).sort();
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      k = _ref1[_j];
      if ((v = obj[k]) != null) {
        out += "" + space + k + "=\"" + v + "\"";
      }
      space = ' ';
    }
    return out;
  };

  _cssFromObject = function(cssMap, isDebug) {
    var css, indent, inline, newline, rules, selector, space, styles;
    if (isDebug == null) {
      isDebug = false;
    }
    newline = isDebug ? '\n' : '';
    space = isDebug ? ' ' : '';
    inline = !isDebug;
    indent = isDebug;
    css = '';
    for (selector in cssMap) {
      styles = cssMap[selector];
      rules = _styleFromObject(styles, {
        inline: inline,
        indent: indent
      });
      css += "" + selector + space + "{" + newline + rules + "}" + newline;
    }
    return css;
  };

  _compileDeeper = function(method, ojml, options) {
    var i;
    i = options.indent;
    options.indent += '\t';
    method(ojml, options);
    return options.indent = i;
  };

  pass = function() {};

  _compileAny = function(ojml, options) {
    var els, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    switch (oj.typeOf(ojml)) {
      case 'array':
        _compileTag(ojml, options);
        break;
      case 'jquery':
        if ((_ref1 = options.html) != null) {
          _ref1.push(ojml.html());
        }
        if ((_ref2 = options.dom) != null) {
          _ref2.concat(ojml.get());
        }
        break;
      case 'string':
        if ((_ref3 = options.html) != null) {
          _ref3.push(ojml);
        }
        if (ojml.length > 0 && ojml[0] === '<') {
          root = document.createElement('div');
          console.log("ojml: ", ojml);
          root.innerHTML = ojml;
          console.log("root: ", root);
          els = root.childNodes;
          if ((_ref4 = options.dom) != null) {
            _ref4.appendChild(root);
          }
        } else {
          if ((_ref5 = options.dom) != null) {
            _ref5.appendChild(document.createTextNode(ojml));
          }
        }
        break;
      case 'boolean':
      case 'number':
        if ((_ref6 = options.html) != null) {
          _ref6.push("" + ojml);
        }
        if ((_ref7 = options.dom) != null) {
          _ref7.appendChild(document.createTextNode("" + ojml));
        }
        break;
      case 'function':
        _compileAny(oj(ojml), options);
        break;
      case 'null':
        break;
      case 'undefined':
        break;
      case 'object':
        break;
      default:
        if (oj.isOJ(ojml)) {
          if ((_ref8 = options.html) != null) {
            _ref8.push(ojml.el.outerHTML);
          }
          if ((_ref9 = options.dom) != null) {
            _ref9.appendChild(ojml.el);
          }
        }
    }
  };

  jqueryEvents = {
    bind: 1,
    on: 1,
    off: 1,
    live: 1,
    blur: 1,
    change: 1,
    click: 1,
    dblclick: 1,
    focus: 1,
    focusin: 1,
    focusout: 1,
    hover: 1,
    keydown: 1,
    keypress: 1,
    keyup: 1,
    mousedown: 1,
    mouseenter: 1,
    mousemove: 1,
    mouseout: 1,
    mouseup: 1,
    ready: 1,
    resize: 1,
    scroll: 1,
    select: 1
  };

  _compileTag = function(ojml, options) {
    var attr, attrName, attrValue, attributes, child, children, ek, el, ev, events, selector, space, styles, tag, tagType, _base, _j, _k, _len1, _len2, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    tag = ojml[0];
    tagType = typeof tag;
    tag = (tagType === 'function' || tagType === 'object') && (tag.type != null) ? tag.type : tag;
    if (!(oj.isString(tag) && tag.length > 0)) {
      throw new Error('oj.compile: tag is missing in array');
    }
    if (_.isCapitalLetter(tag[0])) {
      return _compileDeeper(_compileAny, new oj[tag](ojml.slice(1)), options);
    }
    options.tags[tag] = true;
    attributes = null;
    if (oj.isObject(ojml[1])) {
      attributes = ojml[1];
    }
    children = attributes ? ojml.slice(2) : ojml.slice(1);
    if (options.css && tag === 'css') {
      for (selector in attributes) {
        styles = attributes[selector];
        if ((_ref1 = (_base = options.css)[selector]) == null) {
          _base[selector] = styles;
        }
        _.extend(options.css[selector], styles);
      }
    }
    if (!options.ignore[tag]) {
      _attributeCMeansClass(attributes);
      _attributeStyleAllowsObject(attributes);
      _attributeClassAllowsArrays(attributes);
      events = _attributesFilterOutEvents(attributes);
      if (options.dom && (typeof document !== "undefined" && document !== null)) {
        el = document.createElement(tag);
        if (oj.isDOMElement(options.dom)) {
          options.dom.appendChild(el);
        }
        options.dom = el;
        if (oj.isObject(attributes)) {
          _ref2 = _.keys(attributes).sort();
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            attrName = _ref2[_j];
            attrValue = attributes[attrName];
            el.setAttribute(attrName, attrValue);
          }
        }
        for (ek in events) {
          ev = events[ek];
          if (typeof $ !== "undefined" && $ !== null) {
            if (oj.isArray(ev)) {
              $(el)[ek].apply(this, ev);
            } else {
              $(el)[ek](ev);
            }
          } else {
            console.error("oj: jquery is missing when binding a '" + ek + "' event");
          }
        }
      }
      if (options.html) {
        attr = (_ref3 = _attributesFromObject(attributes)) != null ? _ref3 : '';
        space = attr === '' ? '' : ' ';
        options.html.push("<" + tag + space + attr + ">");
      }
    }
    for (_k = 0, _len2 = children.length; _k < _len2; _k++) {
      child = children[_k];
      if (options.debug && children.length > 1) {
        if ((_ref4 = options.html) != null) {
          _ref4.push("\n\t" + options.indent);
        }
      }
      _compileDeeper(_compileAny, child, options);
    }
    if (options.debug && children.length > 1) {
      if ((_ref5 = options.html) != null) {
        _ref5.push("\n" + options.indent);
      }
    }
    if (!options.ignore[tag]) {
      if (options.html && (children.length > 0 || oj.tag.isClosed(tag))) {
        if ((_ref6 = options.html) != null) {
          _ref6.push("</" + tag + ">");
        }
      }
      if (options.dom) {
        options.dom = options.dom.parentNode;
      }
    }
  };

  _attributeStyleAllowsObject = function(attr) {
    if (oj.isObject(attr != null ? attr.style : void 0)) {
      attr.style = _styleFromObject(attr.style, {
        inline: true
      });
    }
  };

  _attributeCMeansClass = function(attr) {
    if ((attr != null ? attr.c : void 0) != null) {
      attr["class"] = attr.c;
      delete attr.c;
    }
  };

  _attributeClassAllowsArrays = function(attr) {
    if (oj.isArray(attr != null ? attr["class"] : void 0)) {
      attr["class"] = attr.join(' ');
    }
  };

  _attributesFilterOutEvents = function(attr) {
    var k, out, v;
    out = {};
    if (attr) {
      for (k in attr) {
        v = attr[k];
        if (jqueryEvents[k] != null) {
          out[k] = v;
          delete attr[k];
        }
      }
    }
    return out;
  };

  oj.toDOM = function(options, ojml) {
    var result;
    if (!oj.isObject(options)) {
      ojml = options;
      options = {};
    }
    _.extend(options, {
      dom: true,
      html: true,
      css: true
    });
    result = oj.compile(options, ojml);
    if (typeof result.js === "function") {
      result.js();
    }
    return result.dom;
  };

  oj.toHTML = function(options, ojml) {
    if (!oj.isObject(options)) {
      ojml = options;
      options = {};
    }
    _.extend(options, {
      dom: false,
      js: false,
      html: true,
      css: false
    });
    return (oj.compile(options, ojml)).html;
  };

  oj.toCSS = function(options, ojml) {
    if (!oj.isObject(options)) {
      ojml = options;
      options = {};
    }
    _.extend(options, {
      dom: false,
      js: false,
      html: false,
      css: true
    });
    return (oj.compile(options, ojml)).css;
  };

  _.inherit = function(child, parent) {
    var ctor, key;
    for (key in parent) {
      oj.copyProperty(child, parent, key);
    }
    ctor = function() {};
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.prototype["super"] = parent.prototype;
  };

  oj.type = function(name, args) {
    var Out, delay, methodKeys, methods, propKeys, properties, typeProps, _ref1, _ref2, _ref3;
    if (args == null) {
      args = {};
    }
    if (!oj.isString(name)) {
      throw 'oj.type: string expected for first argument';
    }
    if (!oj.isObject(args)) {
      throw 'oj.type: object expected for second argument';
    }
    if ((_ref1 = args.methods) == null) {
      args.methods = {};
    }
    if ((_ref2 = args.properties) == null) {
      args.properties = {};
    }
    if ((_ref3 = args.constructor) == null) {
      args.constructor = function() {};
    }
    delay = '__DELAYED__';
    Out = new Function("return function " + name + "(){\n  var _this = this;\n  if ( !(this instanceof " + name + ") )\n    _this = new " + name + "('" + delay + "');\n\n  if (arguments && arguments[0] != '" + delay + "')\n    " + name + ".prototype.constructor.apply(_this, arguments);\n\n  return _this;\n}")();
    if (args.inherits != null) {
      _.inherit(Out, args.inherits);
    }
    oj.addMethod(Out.prototype, 'constructor', function() {
      if (args.inherits != null) {
        args.inherits.prototype.constructor.apply(this, arguments);
      }
      try {
        args.constructor.apply(this, arguments);
      } catch (e) {
        throw e;
      }
      return this;
    });
    typeProps = {
      type: {
        value: name,
        writable: false,
        enumerable: false
      },
      isOJ: {
        value: true,
        writable: false,
        enumerable: false
      }
    };
    oj.addProperties(Out, typeProps);
    oj.addProperties(Out.prototype, typeProps);
    propKeys = (_.keys(args.properties)).sort();
    if (Out.prototype.properties != null) {
      propKeys = _.uniqueSortedUnion(Out.prototype.properties, propKeys);
    }
    properties = {
      value: propKeys,
      writable: false,
      enumerable: false
    };
    oj.addProperty(Out, 'properties', properties);
    oj.addProperty(Out.prototype, 'properties', properties);
    methodKeys = (_.keys(args.methods)).sort();
    if (Out.prototype.methods != null) {
      methodKeys = _.uniqueSortedUnion(Out.prototype.methods, methodKeys);
    }
    methods = {
      value: methodKeys,
      writable: false,
      enumerable: false
    };
    oj.addProperty(Out, 'methods', methods);
    oj.addProperty(Out.prototype, 'methods', methods);
    _.extend(args.methods, {
      set: function(k, v) {
        var key, obj, value;
        obj = k;
        if (!oj.isObject(k)) {
          obj = {};
          obj[k] = v;
        }
        for (key in obj) {
          value = obj[key];
          this[key] = value;
        }
      },
      toJSON: function() {
        var json, prop, _j, _len1, _ref4;
        json = {};
        _ref4 = this.properties;
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          prop = _ref4[_j];
          json[prop] = this[prop];
        }
        return json;
      }
    });
    oj.addMethods(Out.prototype, args.methods);
    oj.addProperties(Out.prototype, args.properties);
    return Out;
  };

  _.optionsUnion = function(argList) {
    var list, obj, v, _j, _len1;
    obj = {};
    list = [];
    for (_j = 0, _len1 = argList.length; _j < _len1; _j++) {
      v = argList[_j];
      if (oj.isObject(v)) {
        obj = _.extend(obj, v);
      } else {
        list.push(v);
      }
    }
    return {
      options: obj,
      args: list
    };
  };

  oj["enum"] = function(name, args) {
    throw 'NYI';
  };

  oj.View = oj.type('View', {
    constructor: function() {
      var args, options, optionsUnion, _ref1;
      optionsUnion = _.optionsUnion(arguments);
      options = optionsUnion.options, args = optionsUnion.args;
      if ((_ref1 = options.id) == null) {
        options.id = oj.id();
      }
      this._id = options.id;
      _.argumentsAppend(this);
      this.set(options);
      return optionsUnion;
    },
    properties: {
      el: {
        get: function() {
          var $dom, dom, ojml;
          if (oj.isDOMElement(this._el)) {
            return this._el;
          }
          if (typeof $ !== "undefined" && $ !== null) {
            this._el = $('#' + this._id).get(0);
            if (oj.isDOMElement(this._el)) {
              return this._el;
            }
          }
          _.argumentsPush();
          ojml = this.make();
          _.argumentsPop();
          dom = (oj.compile({
            dom: true,
            html: false,
            css: false
          }, ojml)).dom;
          $dom = $(dom);
          if (!$dom.attr('id')) {
            $dom.attr({
              id: oj.id()
            });
          }
          $dom.addClass(this.type);
          return this._el = dom;
        }
      },
      $el: {
        get: function() {
          return $(this.el);
        }
      },
      id: {
        get: function() {
          return this._id;
        }
      },
      attributes: {
        get: function() {
          return this.$el.attributes();
        },
        set: function() {
          var _ref1;
          return (_ref1 = this.$el).attributes.apply(_ref1, arguments);
        }
      },
      hidden: {
        get: function() {
          return $el.css('display') === 'none';
        },
        set: function(v) {
          if (v) {
            return $el.hide();
          } else {
            return $el.show();
          }
        }
      }
    },
    methods: {
      make: function() {
        return oj.div();
      },
      $: function() {
        return this.$el.find.apply(this, arguments);
      },
      toHTML: function(options) {
        console.log("---- CALLING toHTML");
        return this.el.outerHTML + (options.debug ? '\n' : '');
      },
      toDOM: function() {
        console.log("---- CALLING toDOM");
        return this.el;
      },
      toString: function() {
        console.log("---- CALLING toHTML");
        return this.toHTML();
      },
      detach: function() {
        throw 'detach nyi';
      },
      attach: function() {
        throw 'attach nyi';
      }
    }
  });

  oj.ModelView = oj.type('ModelView', {
    inherits: oj.View,
    properties: {
      model: {
        get: function() {
          return this._model;
        },
        set: function(v) {
          if (oj.isBackbone(this._model)) {
            this._model.off('change', this.modelChange);
          }
          this._model = v;
          if (oj.isBackbone(this._model)) {
            this._model.on('change', this.modelChange);
          }
        }
      }
    },
    methods: {
      modelChange: function() {},
      viewChange: function() {}
    }
  });

  oj.FormView = oj.type('FormView', {
    inherits: oj.ModelView,
    properties: {
      key: {
        get: function() {
          return this._key;
        },
        set: function(v) {
          this._key = v;
        }
      },
      value: {
        get: function() {
          throw 'value get needs override';
        },
        set: function(v) {
          throw 'value set needs override';
        }
      },
      change: {
        get: function() {
          return this._change;
        },
        set: function(v) {
          this._change = v;
        }
      },
      formValue: {
        get: function() {
          return this.$el.attr('value');
        },
        set: function(v) {
          this.$el.attr('value', v);
        }
      }
    },
    methods: {
      modelChange: function() {
        if ((this.model != null) && (this.key != null)) {
          return this.value = this.model[this.key];
        }
      },
      viewChange: function() {
        if ((this.model != null) && (this.key != null)) {
          this.model[this.key] = this.value;
        }
        return typeof this.change === "function" ? this.change(this) : void 0;
      }
    }
  });

  oj.TextBox = oj.type('TextBox', {
    inherits: oj.FormView,
    properties: {
      value: {
        get: function() {
          return this.el.value;
        },
        set: function(v) {
          this.el.value = v;
        }
      }
    },
    methods: {
      make: function(props) {
        var _this = this;
        return oj.input({
          type: 'text',
          change: function() {
            return _this.viewChange();
          }
        });
      }
    }
  });

  oj.CheckBox = oj.type('CheckBox', {
    inherits: oj.FormView,
    properties: {
      value: {
        get: function() {
          return this.el.checked;
        },
        set: function(v) {
          v = !!v;
          this.el.checked = v;
          if (v) {
            this.$el.attr('checked', 'checked');
          } else {
            this.$el.removeAttr('checked');
          }
        }
      }
    },
    methods: {
      make: function(props) {
        var _this = this;
        return oj.input({
          type: 'checkbox',
          change: function() {
            return _this.viewChange();
          }
        });
      }
    }
  });

  oj.TextArea = oj.type('TextArea', {
    inherits: oj.FormView,
    properties: {
      value: {
        get: function() {
          return this.el.value;
        },
        set: function(v) {
          this.el.value = v;
        }
      }
    },
    methods: {
      make: function(props) {
        var _this = this;
        return oj.textarea({
          change: function() {
            return _this.viewChange();
          }
        });
      }
    }
  });

  oj.sandbox = {};

  _ref1 = _.keys(oj);
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    key = _ref1[_j];
    if (key.length > 0 && key[0] !== '_') {
      oj.addProperty(oj.sandbox, key, {
        value: oj[key],
        writable: false
      });
    }
  }

  oj.use = function(plugin, settings) {
    var name, pluginMap, value, _results;
    if (settings == null) {
      settings = {};
    }
    if (!oj.isFunction(plugin)) {
      throw new Error('oj.use: function expected for first argument');
    }
    if (!oj.isObject(settings)) {
      throw new Error('oj.use: object expected for second argument');
    }
    pluginMap = plugin(oj, settings);
    _results = [];
    for (name in pluginMap) {
      value = pluginMap[name];
      oj[name] = value;
      _results.push(oj.addProperty(oj.sandbox, name, {
        value: value,
        writable: false
      }));
    }
    return _results;
  };

}).call(this);
})(P,G,'/','oj');});

P = {cwd: function(){return '/';}};
G = {process: P,Buffer: {}};
RR = function(f){
  return function(m){
    return run(find(m, f));
  };
  function run(f){
    if(R[f] != null)
      return R[f];
    var eo = {},
      mo = {exports: eo};
    if(typeof F[f] != 'function')
      throw new Error("file not found (" + f + ")");
    F[f](mo,eo);
    return R[f] = mo.exports;
  }
  function find(m,f){
    var r, dir, dm, ext, ex, i;

    if (F[m] && !m.match(/\//)) {
      return m;
    }

    if (!!m.match(/\//)) {
      r = oj.__.pathResolve(f, oj.__.pathJoin(oj.__.pathDirname(f), m));
      ext = ['.ojc','.oj','.coffee','.js','.json'];
      for(i = 0; i < ext.length; i++){
        ex = ext[i];
        if(F[r+ex])
          return r+ex;
      }
    } else {
      dir = oj.__.pathDirname(f);
      while(true) {
        dm = oj.__.pathJoin(dir, 'node_modules');
        if(M[dm] && M[dm][m])
          return oj.__.pathJoin(dm, m, M[dm][m]);
        if(dir == '/')
          break;
        dir = oj.__.pathResolve(dir, '..');
      }
    }
    throw new Error("module not found (" + m + ")");
  }
};

require = RR('/try');
oj = require('oj');
oj.begin('/try');

}).call(this);

</script></body>
</html>